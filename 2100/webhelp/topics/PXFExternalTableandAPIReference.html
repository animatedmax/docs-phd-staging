
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head><meta xmlns="http://www.w3.org/1999/xhtml" name="description" content="The Java API lets you extend PXF functionality and add new services and formats without changing HAWQ. The API includes four classes: Fragmenter, Accessor, Resolver, and Analyzer. The Fragmenter, ..."/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="copyright" content="(C) Copyright 2005"/><meta name="DC.rights.owner" content="(C) Copyright 2005"/><meta name="DC.Type" content="topic"/><meta name="DC.Title" content="PXF External Table and API Reference"/><meta name="DC.Relation" scheme="URI" content="../topics/PivotalExtensionFrameworkPXF.html"/><meta name="prodname" content=""/><meta name="version" content="2.1.0"/><meta name="release" content=""/><meta name="modification" content=""/><meta name="DC.Format" content="XHTML"/><meta name="DC.Identifier" content="pxfexternaltableandapireference"/><link rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>PXF External Table and API Reference</title><meta xmlns="http://www.w3.org/1999/xhtml" http-equiv="Content-Type" content="text/html; charset=utf-8"><!----></meta><link xmlns="http://www.w3.org/1999/xhtml" rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/commonltr.css"><!----></link><link xmlns="http://www.w3.org/1999/xhtml" rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/pivotal.css"/><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript"><!--
          
          var prefix = "../index.html";
          
          --></script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" src="../oxygen-webhelp/resources/js/jquery-1.8.2.min.js"><!----></script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" src="../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" src="../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" charset="utf-8" src="../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script></head>
<body onload="highlightSearchTerm()" id="pxfexternaltableandapireference"><script xmlns="http://www.w3.org/1999/xhtml" src="//use.typekit.net/clb0qji.js" type="text/javascript"/><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
			  try {
				  Typekit.load();
			  } catch (e) {
			  }
		  </script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
			  document.domain = "pivotal.io";
		  </script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
			WebFontConfig = {
			  google: { families: [ 'Source+Sans+Pro:300italic,400italic,300,400,600:latin' ] }
			};
			(function() {
			  var wf = document.createElement('script');
			  wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
				'://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
			  wf.type = 'text/javascript';
			  wf.async = 'true';
			  var s = document.getElementsByTagName('script')[0];
			  s.parentNode.insertBefore(wf, s);
			})();
		  </script>
<table class="nav"><tbody><tr><td colspan="2"><div id="permalink"><a href="#" title="Link to this page"/></div><div id="printlink"><a href="javascript:window.print();" title="Print this page"/></div></td></tr><tr><td width="75%"><a class="navheader_parent_path" href="../topics/../topics/PivotalHAWQ.html" title="Pivotal HAWQ">Pivotal HAWQ</a> / <a class="navheader_parent_path" href="../topics/PivotalExtensionFrameworkPXF.html" title="Pivotal Extension Framework (PXF)">Pivotal Extension Framework (PXF)</a></td><td><div class="navheader">
<span class="navparent"><a class="link" href="../topics/PivotalExtensionFrameworkPXF.html" title="Pivotal Extension Framework (PXF)"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">Pivotal Extension Framework (PXF)</span></a></span>  </div></td></tr></tbody></table>

   <h1 class="title topictitle1">PXF External Table and API Reference</h1>

   <div class="body">
      <p class="p">The Java API lets you extend PXF functionality and add new services and formats without
         changing HAWQ. The API includes four classes: Fragmenter, Accessor, Resolver, and Analyzer.
         The Fragmenter, Accessor, and Resolver classes must be implemented to add a new service.
         The Analyzer class is optional.</p>

   </div>

   <div class="related-links"/>
<div class="topic nested1" id="creatinganexternaltable">
      <h2 class="title topictitle2">Creating an External Table</h2>

      <div class="body">
         <p class="p">Syntax for an <samp class="ph codeph">EXTERNAL TABLE</samp> that uses the PXF protocol is as
            follows:.</p>

         <pre class="pre codeblock">CREATE EXTERNAL TABLE ext_table &lt;attr list, ...&gt;
LOCATION('pxf://&lt;namenode&gt;:&lt;port&gt;/path/to/data?FRAGMENTER=package.name.FragmenterForX&amp;ACCESSOR=package.name.AccessorForX&amp;RESOLVER=package.name.ResolverForX&amp;&lt;Other custom user options&gt;=&lt;value&gt;')FORMAT 'custom'(formatter='pxfwritable_import');</pre>

         <p class="p"> Where:</p>

         
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="creatinganexternaltable__table_pfy_htz_4p" class="table" frame="border" border="1" rules="all"><caption><span class="tablecap">Table 1. Parameter values and description</span></caption>
               <thead class="thead" align="left">
                  <tr class="row">
                     <th class="entry confluenceTd" valign="top" id="d136731e64">
                        <p class="p"> Parameter </p>

                     </th>

                     <th class="entry confluenceTd" valign="top" id="d136731e70">
                        <p class="p"> Value and description </p>

                     </th>

                  </tr>

               </thead>

               <tbody class="tbody">
                  <tr class="row">
                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">
                        <p class="p">namenode</p>

                     </td>

                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">
                        <p class="p">The current host of the PXF service is HDFS Namenode port.</p>

                     </td>

                  </tr>

                  <tr class="row">
                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">
                        <p class="p">REST </p>

                     </td>

                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">
                        <p class="p">Port for Namenode, 50070 by default.</p>

                     </td>

                  </tr>

                  <tr class="row">
                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">path/to/data</td>

                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 "> A directory, file name, wildcard pattern,
                        table name, etc.</td>

                  </tr>

                  <tr class="row">
                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">FRAGMENTER</td>

                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 "> The plugin (Java class) to use for
                        fragmenting data. Used in READABLE external tables only.</td>

                  </tr>

                  <tr class="row">
                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">ACCESSOR</td>

                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">The plugin (Java class) to use for accessing
                        the data. Used in READABLE and WRITABLE tables.</td>

                  </tr>

                  <tr class="row">
                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">RESOLVER</td>

                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">The plugin (java class) to use for
                        serializing and deserializing the data. Used in READABLE and WRITABLE
                        tables.</td>

                  </tr>

                  <tr class="row">
                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">Custom Options</td>

                     <td class="entry confluenceTd" valign="top" headers="d136731e64 d136731e70 ">Anything else that is desired to add. Will be
                        passed in runtime to the plugins indicated above. </td>

                  </tr>

               </tbody>

            </table>
</div>

         <p class="p">For more information about this example, see <a class="xref" href="#aboutthejavaclassservicesandformats">About the Java Class Services and
               Formats</a> and <a class="xref" href="PXFInstallationandAdministration.html">PXF Installation and Administration</a>. </p>

      </div>

   </div>

   <div class="topic nested1" id="aboutthejavaclassservicesandformats">
      <h2 class="title topictitle2">About the Java Class Services and Formats</h2>

      <div class="body">
         <p class="p">The Java class names you must include in the PXF URI are: Fragmenter, Accessor, and
            Resolver. The Fragmenter class  is mandatory for READABLE tables, and not supported for
            WRITABLE tables. Pivotal recommends that you reuse a previously-defined Accessor or
            Resolver data format.</p>

         <p class="p">All the attributes are passed from HAWQ as headers to the PXF Java service. The Java
            service retrieves the source data and converts it to a HAWQ-readable format. You can
            pass any additional information to the user-implemented services.</p>

         <p class="p">The example in <a class="xref" href="#creatinganexternaltable">Creating an External Table</a>
            shows the available keys and associated values. The example also contains attributes
            that are passed in from the HAWQ side. The available keys and associated values are as
            follows:</p>

         <pre class="pre codeblock">FRAGMENTER: ‘pkg.name.FragmenterForX’
ACCESSOR: ‘pkg.name.AccessorForX’
RESOLVER: ‘pkg.name.ResolverForX’
</pre>

         <p class="p">These three Java plugins and the optional plugin, Analyzer, extend the
               <samp class="ph codeph">com.pivotal.pxf.api.utilities.Plugin</samp> class.</p>

         <p class="p">The Java classes can be described as follows:</p>

         <pre class="pre codeblock">package com.pivotal.pxf.api.utilities;
/**
 * Base class for all plugin types (Accessor, Resolver, Fragmenter, Analyzer, ...).
 * Manages the meta data.
 */
public class Plugin {
    protected InputData inputData;
    /**
     * Constructs a plugin.
     *
     * @param input the input data
     */
    public Plugin(InputData input) {
        this.inputData = input;
    }
    /**
     * Checks if the plugin is thread safe or not, based on inputData.
     *
     * @return true if plugin is thread safe
     */
    public boolean isThreadSafe() {
        return true;
    }
}</pre>

         <p class="p">Attributes are available through the
               <samp class="ph codeph">com.pivotal.pxf.api.utilities.InputData</samp> class. The following example
            shows how <samp class="ph codeph">inputData.getProperty(‘USERINFO1’)</samp> returns
               <samp class="ph codeph">optional_info</samp>.</p>

         <pre class="pre codeblock">/**
 * Common configuration available to all PXF plugins. Represents input data
 * coming from client applications, such as Hawq.
 */
public class InputData {

    /**
     * Constructs an InputData from a copy.
     * Used to create from an extending class.
     *
     * @param copy the input data to copy
     */
    public InputData(InputData copy);

    /**
     * Returns a user defined property.
     *
     * @param userProp the lookup user property
     * @return property value as a String
     */
    public String getUserProperty(String userProp);

    /** Returns the request parameters */
    public Map&lt;String, String&gt; getParametersMap();

    /**
     * set the byte serialization of a fragment meta data
     * @param location start, len, and location of the fragment
     */
    public void setFragmentMetadata(byte[] location);
    /** the byte serialization of a data fragment */
    public byte[] getFragmentMetadata();

    /** 
     * Gets any custom user data that may have been passed from the 
     * fragmenter. Will mostly be used by the accessor or resolver. 
     */
    public byte[] getFragmentUserData();

    /** 
     * Sets any custom user data that needs to be shared across plugins. 
     * Will mostly be set by the fragmenter. 
     */
    public void setFragmentUserData(byte[] userData);

    /** Returns the number of segments in GP. */
    public int getTotalSegments();

    /** Returns the current segment ID. */
    public int getSegmentId();

    /** Returns true if there is a filter string to parse. */
    public boolean hasFilter();

    /** Returns the filter string, &lt;tt&gt;null&lt;/tt&gt; if #hasFilter is &lt;tt&gt;false&lt;/tt&gt; */
    public String getFilterString();

    /** Returns tuple description. */
    public ArrayList&lt;ColumnDescriptor&gt; getTupleDescription();

    /** Returns the number of columns in tuple description. */
    public int getColumns();

    /** Returns column index from tuple description. */
    public ColumnDescriptor getColumn(int index);

	/**
	 * Returns the column descriptor of the recordkey column. If the recordkey
	 * column was not specified by the user in the create table statement will
	 * return null.
	 */
    public ColumnDescriptor getRecordkeyColumn();

    /** Returns the data source of the required resource (i.e a file path or a table name). */
    public String getDataSource();

    /** Sets the data source for the required resource */
    public void setDataSource(String dataSource);

    /** Returns the path of the schema used for various deserializers e.g, Avro file name, Java object file name. */
    public void verifyDataSchemaAccessible() throws FileNotFoundException, IllegalArgumentException;
    
    /** Returns the path of the schema used for various deserializers e.g, Avro file name, Java object file name. */
    public String getDataSchemaName();

    /** Returns the ClassName for the java class that was defined as Accessor */
    public String getAccessor();

    /** Returns the ClassName for the java class that was defined as Resolver */
    public String getResolver();

	/**
	 * Returns the ClassName for the java class that was defined as Fragmenter
	 * or null if no fragmenter was defined
	 */
    public String getFragmenter();

	/**
	 * Returns the ClassName for the java class that was defined as Analyzer or
	 * null if no analyzer was defined
	 */
    public String getAnalyzer();

    /** Returns the compression codec name (&lt;tt&gt;null&lt;/tt&gt; means no compression) */
    public String getCompressCodec();

    /**
     * Returns the compression type (can be null)
     * Allowed values: RECORD, BLOCK.
     */
    public String getCompressType();

    /**
     * Returns the contents of pxf_remote_service_login set in Hawq.
     * Should the user set it to an empty string this function will return null.
     *
     * @return remote login details if set, null otherwise
     */
    public String getLogin();

    /**
     * Returns the contents of pxf_remote_service_secret set in Hawq.
     * Should the user set it to an empty string this function will return null.
     *
     * @return remote password if set, null otherwise
     */
    public String getSecret();

    public boolean isThreadSafe();

	/** 
	 * Returns a data fragment index. plan to deprecate it in favor of using
	 * getFragmentMetadata().
	 */
	public int getDataFragment();
}</pre>

      </div>

      <div class="topic nested2" id="fragmenter">
         <h3 class="title topictitle3">Fragmenter</h3>

         <div class="body">
            <div class="note note"><span class="notetitle">Note:</span> The Fragmenter Plugin reads data into HAWQ. Such tables are called READABLE PXF
               tables. The Fragmenter Plugin cannot write data out of HAWQ. Such tables are
               calledWRITABLE tables.</div>

            <p class="p">The Fragmenter is responsible for passing datasource metadata back to HAWQ. It also
               returns a list of data fragments to the Accessor or Resolver. Each data fragment
               describes some part of the requested data set. It contains the datasource name, such
               as the file or table name, including the hostname where it is located. For example,
               if the source is a HDFS file, the Fragmenter returns a list of data fragments
               containing a HDFS file block. Each fragment includes the location of the block. If
               the source data is an HBase table, the Fragmenter returns information about table
               regions, including their locations.</p>

            <p class="p">The following implementations are shipped with PXF 2.2 and higher:</p>

            <pre class="pre codeblock">com.pivotal.pxf.plugins.hdfs.HdfsDataFragmenter
com.pivotal.pxf.plugins.hbase.HBaseDataFragmenter
com.pivotal.pxf.plugins.hive.HiveDataFragmenter</pre>

            <p class="p">The Fragmenter.getFragments() methods returns a List&lt;Fragment&gt;:</p>

            <pre class="pre codeblock">package com.pivotal.pxf.api;
/*
 * Fragment holds a data fragment' information.
 * Fragmenter.getFragments() returns a list of fragments.
 */
public class Fragment
{
 	private String sourceName;    // File path+name, table name, etc.
    private int index;        // Fragment index (incremented per sourceName)
    private String[] replicas;    // Fragment replicas (1 or more)
    private byte[] metadata;    // Fragment metadata information (starting point + length, region location, etc.)
    private byte[] userData;    // ThirdParty data added to a fragment. Ignored if null
	...
}</pre>

            <p class="p">Any Fragmenter class needs to extend
               <samp class="ph codeph">com.pivotal.pxf.api.Fragmenter</samp>:</p>

         </div>

         <div class="topic nested3" id="com.pivotal.pxf.api.fragmenter">
            <h4 class="title topictitle4">com.pivotal.pxf.api.Fragmenter</h4>

            <div class="body">
               <pre class="pre codeblock">package com.pivotal.pxf.api;
/*
 * Interface that defines the splitting of a data resource into fragments that can be processed in parallel
 * GetFragments returns the fragments information of a given path (source name and location of each fragment).
 * Used to get fragments of data that could be read in parallel from the different segments.
 */
public abstract class Fragmenter extends Plugin {
    	protected List&lt;Fragment&gt; fragments;
	
	public Fragmenter(InputData metaData) {
		super(metaData);
		fragments = new LinkedList&lt;Fragment&gt;();
	}
	
	/*
	 * path is a data source URI that can appear as a file name, a directory name  or a wildcard
	 * returns the data fragments
	 */
	public abstract List&lt;Fragment&gt; getFragments() throws Exception;
}   </pre>

            </div>

         </div>

         <div class="topic nested3" id="classdescription">
            <h4 class="title topictitle4">Class Description</h4>

            <div class="body">
               <p class="p"><samp class="ph codeph">getFragments()</samp> returns a string in a JSON format of the retrieved
                  fragment. For example, if the input path is a HDFS directory, the source name for
                  each fragment should include the file name including the path for the
                  fragment.  </p>

            </div>

         </div>

      </div>

      <div class="topic nested2" id="accessor">
         <h3 class="title topictitle3">Accessor</h3>

         <div class="body">
            <p class="p">The Accessor retrieves specific fragments and passes records back to the
               Resolver. For example, the Accessor creates a <samp class="ph codeph">FileInputFormat</samp> and a
               Record Reader for an HDFS file and sends this to the Resolver. In the case of HBase
               or Hive files, the Accessor returns single rows from an HBase or Hive table. PXF 1.x
               or higher contains the following implementations:</p>

            
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="accessor__table_ewm_ttz_4p" class="table" frame="border" border="1" rules="all"><caption><span class="tablecap">Table 2. Accessor base classes </span></caption>
                  <thead class="thead" align="left">
                     <tr class="row">
                        <th class="entry confluenceTd" valign="top" id="d136731e308">
                           <p class="p">
                              <samp class="ph codeph">Accessor class</samp>
                           </p>

                        </th>

                        <th class="entry confluenceTd" valign="top" id="d136731e317">
                           <p class="p">
                              <samp class="ph codeph">Description</samp>
                           </p>

                        </th>

                     </tr>

                  </thead>

                  <tbody class="tbody">
                     <tr class="row">
                        <td class="entry confluenceTd" valign="top" headers="d136731e308 d136731e317 ">
                           <p class="p"> com.pivotal.pxf.plugins.hdfs.HdfsAtomicDataAccessor </p>

                        </td>

                        <td class="entry confluenceTd" valign="top" headers="d136731e308 d136731e317 ">
                           <p class="p">Base class for accessing datasources which cannot be split. These will
                              be accessed by a single HAWQ segment.</p>

                           <pre class="pre codeblock">QuotedLineBreakAccessor - Accessor for TEXT files that has records with embedded linebreaks</pre>

                        </td>

                     </tr>

                     <tr class="row">
                        <td class="entry confluenceTd" valign="top" headers="d136731e308 d136731e317 ">
                           <p class="p"> com.pivotal.pxf.plugins.hdfs.HdfsSplittableDataAccessor </p>

                        </td>

                        <td class="entry confluenceTd" valign="top" headers="d136731e308 d136731e317 ">
                           <p class="p">Base class for accessing HDFS files using
                                 <samp class="ph codeph">RecordReaders</samp>:</p>

                           <pre class="pre codeblock">LineBreakAccessor - Accessor for TEXT files (replaced the deprecated TextFileAccessor, LineReaderAccessor)
AvroFileAccessor - Accessor for Avro files
</pre>

                        </td>

                     </tr>

                     <tr class="row">
                        <td class="entry confluenceTd" valign="top" headers="d136731e308 d136731e317 ">com.pivotal.pxf.plugins.hive.HiveAccessor</td>

                        <td class="entry confluenceTd" valign="top" headers="d136731e308 d136731e317 ">Accessor for Hive tables </td>

                     </tr>

                     <tr class="row">
                        <td class="entry confluenceTd" valign="top" headers="d136731e308 d136731e317 ">com.pivotal.pxf.plugins.hbase.HBaseAccessor </td>

                        <td class="entry confluenceTd" valign="top" headers="d136731e308 d136731e317 ">Accessor for HBase tables </td>

                     </tr>

                  </tbody>

               </table>
</div>

            <p class="p">The class must extend the <samp class="ph codeph">com.pivotal.pxf.Plugin
               class,</samp> and implement one or both interfaces:
            </p>

            <ul class="ul" id="accessor__ul_edl_wtz_4p">
               <li class="li">
                  <samp class="ph codeph">com.pivotal.pxf.api.ReadAccessor</samp>
               </li>

               <li class="li">
                  <samp class="ph codeph">com.pivotal.pxf.api.WriteAccessor</samp>
               </li>

            </ul>

            <pre class="pre codeblock">package com.pivotal.pxf.api;
/*
 * Internal interface that defines the access to data on the source
 * data store (e.g, a file on HDFS, a region of an HBase table, etc).
 * All classes that implement actual access to such data sources must 
 * respect this interface
 */
public interface ReadAccessor {
	public boolean openForRead() throws Exception;
	public OneRow readNextObject() throws Exception;
	public void closeForRead() throws Exception;
}</pre>

            <pre class="pre codeblock">package com.pivotal.pxf.api;
/*
 * An interface for writing data into a data store
 * (e.g, a sequence file on HDFS).
 * All classes that implement actual access to such data sources must 
 * respect this interface
 */
public interface WriteAccessor {
	public boolean openForWrite() throws Exception;
	public OneRow writeNextObject(OneRow onerow) throws Exception;
	public void closeForWrite() throws Exception;
}</pre>

            <p class="p">The Accessor calls <samp class="ph codeph">openForRead()</samp> to read existing data. After
               reading the data, it calls <samp class="ph codeph">closeForRead()</samp>.
                  <samp class="ph codeph">readNextObject()</samp> and returns one of the following:</p>

            <ul class="ul" id="accessor__ul_pll_wtz_4p">
               <li class="li">a single record, encapsulated in a OneRow object</li>

               <li class="li">null if it reaches <samp class="ph codeph">EOF</samp>
               </li>

            </ul>

            <p class="p">The Accessor calls <samp class="ph codeph">openForWrite() </samp>to write data out. After writing
               the data, it writes a <samp class="ph codeph">OneRow</samp> object with
                  <samp class="ph codeph">writeNextObject()</samp>, and when done calls
                  <samp class="ph codeph">closeForWrite()</samp>. <samp class="ph codeph">OneRow</samp> represents a key-value
               item.</p>

         </div>

         <div class="topic nested3" id="com.pivotal.pxf.api.onerow">
            <h4 class="title topictitle4">com.pivotal.pxf.api.OneRow:</h4>

            <div class="body">
               <pre class="pre codeblock">package com.pivotal.pxf.api;
/*
 * Represents one row in the external system data store. Supports
 * the general case where one row contains both a record and a
 * separate key like in the HDFS key/value model for MapReduce
 * (Example: HDFS sequence file)
 */
public class OneRow {
    /*
     * Default constructor
     */
    public OneRow()

    /*
     * Constructor sets key and data
     */
    public OneRow(Object inKey, Object inData)

    /*
     * Copy constructor
     */
    public OneRow(OneRow copy)
　
    /*
     * Setter for key
     */
    public void setKey(Object inKey)
　
    /*
     * Setter for data
     */
    public void setData(Object inData)
    /*
     * Accessor for key
     */
    public Object getKey()
　
    /*
     * Accessor for data
     */
    public Object getData()
　
    /*
     * Show content
     */
    public String toString()
}</pre>

            </div>

         </div>

      </div>

      <div class="topic nested2" id="resolver">
         <h3 class="title topictitle3">Resolver</h3>

         <div class="body">
            <p class="p">The Resolver deserializes records in the <samp class="ph codeph">OneRow</samp> format and
               serializes them to a list of <samp class="ph codeph">OneField</samp> objects. PXF converts a
                  <samp class="ph codeph">OneField</samp> object to a HAWQ-readable <samp class="ph codeph">GPDBWritable</samp>
               format. PXF 1.x or higher contains the following implementations:</p>

            
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="resolver__table_nbd_d5z_4p" class="table" frame="border" border="1" rules="all"><caption><span class="tablecap">Table 3. Resolver base classes</span></caption>
                  <thead class="thead" align="left">
                     <tr class="row">
                        <th class="entry confluenceTd" valign="top" id="d136731e507">
                           <p class="p">
                              <samp class="ph codeph">Resolver class</samp>
                           </p>

                        </th>

                        <th class="entry confluenceTd" valign="top" id="d136731e516">
                           <p class="p">
                              <samp class="ph codeph">Description</samp>
                           </p>

                        </th>

                     </tr>

                  </thead>

                  <tbody class="tbody">
                     <tr class="row">
                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">
                              <samp class="ph codeph">com.pivotal.pxf.plugins.hdfs.StringPassResolver</samp>
                           </p>

                        </td>

                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">Supports:</p>

                           <pre class="pre codeblock">GPBWritable VARCHAR</pre>

                           <p class="p">
                              <samp class="ph codeph">StringPassResolver </samp>replaced the deprecated
                                 <samp class="ph codeph">TextResolver. </samp>It passes whole records (composed of
                              any data types) as strings without parsing them</p>

                        </td>

                     </tr>

                     <tr class="row">
                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">
                              <samp class="ph codeph">com.pivotal.pxf.plugins.hdfs.WritableResolver</samp>
                           </p>

                        </td>

                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">Resolver for custom Hadoop Writable implementations. Custom class can
                              be specified with the schema<samp class="ph codeph"> {{,}}</samp> and supports the
                              following:</p>

                           <pre class="pre codeblock">DataType.BOOLEAN
DataType.INTEGER
DataType.BIGINT
DataType.REAL
DataType.FLOAT8
DataType.VARCHAR
DataType.BYTEA</pre>

                        </td>

                     </tr>

                     <tr class="row">
                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">
                              <samp class="ph codeph">com.pivotal.pxf.plugins.hdfs.AvroResolver</samp>
                           </p>

                        </td>

                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">Supports the same field objects as
                              <samp class="ph codeph">WritableResolver</samp>. </p>

                        </td>

                     </tr>

                     <tr class="row">
                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">
                              <samp class="ph codeph">com.pivotal.pxf.plugins.hbase.HBaseResolver</samp>
                           </p>

                        </td>

                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">Supports the same field objects as <samp class="ph codeph">WritableResolver</samp>
                              and also supports the following:</p>

                           <pre class="pre codeblock">DataType.SMALLINT
DataType.NUMERIC
DataType.TEXT
DataType.BPCHAR
DataType.TIMESTAMP</pre>

                        </td>

                     </tr>

                     <tr class="row">
                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">
                              <samp class="ph codeph">com.pivotal.pxf.plugins.hive.HiveResolver</samp>
                           </p>

                        </td>

                        <td class="entry confluenceTd" valign="top" headers="d136731e507 d136731e516 ">
                           <p class="p">Supports the same field objects as <samp class="ph codeph">WritableResolver</samp>
                              and also supports the following:</p>

                           <pre class="pre codeblock">DataType.SMALLINT
DataType.TEXT
DataType.TIMESTAMP</pre>

                        </td>

                     </tr>

                  </tbody>

               </table>
</div>

            <p class="p">The class needs to extend the <samp class="ph codeph">com.pivotal.pxf.resolvers.Plugin class
               </samp>, and implement one or both interface<samp class="ph codeph">s: </samp>
            </p>

            <ul class="ul" id="resolver__ul_rkd_d5z_4p">
               <li class="li">
                  <samp class="ph codeph">com.pivotal.pxf.api.ReadResolver</samp>
               </li>

               <li class="li">
                  <samp class="ph codeph">com.pivotal.pxf.api.WriteResolver</samp>
               </li>

            </ul>

            <pre class="pre codeblock">package com.pivotal.pxf.api;
/*
 * Interface that defines the deserialization of one record brought from
 * the data Accessor. Every implementation of a deserialization method
 * (e.g, Writable, Avro, ...) must implement this interface.
 */
public interface ReadResolver {  
    public List&lt;OneField&gt; getFields(OneRow row) throws Exception;
}</pre>

            <pre class="pre codeblock">package com.pivotal.pxf.api;
/*
* Interface that defines the serialization of data read from the DB
* into a OneRow object.
* Every implementation of a serialization method 
* (e.g, Writable, Avro, ...) must implement this interface.
*/
public interface WriteResolver {
    public OneRow setFields(List&lt;OneField&gt; record) throws Exception;
}</pre>

            <div class="note note"><span class="notetitle">Note:</span> 
               <ul class="ul" id="resolver__ul_rtd_d5z_4p">
                  <li class="li">getFields should return a List&lt;OneField&gt;, each OneField representing a
                     single field.</li>

                  <li class="li">
                     <samp class="ph codeph">setFields </samp>should return a
                     single <samp class="ph codeph">OneRow </samp>object, given a List&lt;OneField&gt;.</li>

               </ul>

            </div>

         </div>

         <div class="topic nested3" id="com.pivotal.pxf.api.onefield">
            <h4 class="title topictitle4">com.pivotal.pxf.api.OneField</h4>

            <div class="body">
               <pre class="pre codeblock">package com.pivotal.pxf.api;
/*
 * Defines one field on a deserialized record.
 * 'type' is in OID values recognized by GPDBWritable
 * 'val' is the actual field value
 */
public class OneField {
    public OneField() {}
    public OneField(int type, Object val)    {
        this.type = type;
        this.val = val;
    }

    public int type;
    public Object val;
}</pre>

               <p class="p">The value of t<samp class="ph codeph">ype</samp> should follow the
                     com.pivotal.pxf.api.io.DataType <samp class="ph codeph">enums</samp>. <samp class="ph codeph">val</samp> is
                  the appropriate Java class. Supported types are as follows:</p>

               
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="com.pivotal.pxf.api.onefield__table_f4x_35z_4p" class="table" frame="border" border="1" rules="all"><caption><span class="tablecap">Table 4. Resolver supported types</span></caption>
                     <thead class="thead" align="left">
                        <tr class="row">
                           <th class="entry confluenceTd" valign="top" id="d136731e738">
                              <p class="p"> DataType recognized OID </p>

                           </th>

                           <th class="entry confluenceTd" valign="top" id="d136731e744">
                              <p class="p"> Field value </p>

                           </th>

                        </tr>

                     </thead>

                     <tbody class="tbody">
                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.SMALLINT</samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">Short</samp>
                              </p>

                           </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.INTEGER</samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">Integer</samp>
                              </p>

                           </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.BIGINT</samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">Long</samp>
                              </p>

                           </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.REAL </samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">Float</samp>
                              </p>

                           </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.FLOAT8</samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">Double</samp>
                              </p>

                           </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.NUMERIC</samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">String ( "651687465135468432168421") </samp>
                              </p>

                           </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.BOOLEAN</samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">Boolean</p>

                           </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.VARCHAR</samp>
                                 <samp class="ph codeph"> </samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 "> </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <samp class="ph codeph">DataType.BPCHAR</samp>
                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 "> </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <samp class="ph codeph">DataType.TEXT</samp>
                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <samp class="ph codeph">String</samp>
                           </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.BYTEA</samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">byte [] </samp>
                              </p>

                           </td>

                        </tr>

                        <tr class="row">
                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">DataType.TIMESTAMP</samp>
                              </p>

                           </td>

                           <td class="entry confluenceTd" valign="top" headers="d136731e738 d136731e744 ">
                              <p class="p">
                                 <samp class="ph codeph">Timestamp</samp>
                              </p>

                           </td>

                        </tr>

                     </tbody>

                  </table>
</div>

            </div>

         </div>

      </div>

      <div class="topic nested2" id="analyzer">
         <h3 class="title topictitle3">Analyzer</h3>

         <div class="body">
            <p class="p">The Analyzer provides PXF statistical data for the HAWQ query optimizer. For
               a detailed explanation about HAWQ statistical data gathering, see
                  <samp class="ph codeph">ANALYZE</samp> in the SQL Command Reference of the <a class="xref" href="HAWQAdministration.html">HAWQ Administration</a>. Implement the PXF Analyzer for the HDFS text,
               sequence, and AVRO files. For HBase tables and Hive tables, the Analyzer returns
               default values.</p>

            <div class="note note"><span class="notetitle">Note:</span> 
               <ul class="ul" id="analyzer__ul_myn_q5z_4p">
                  <li class="li">The new <samp class="ph codeph">boolean guc pxf_enable_stat_collection</samp> requests
                     statistics. The default value is <samp class="ph codeph">on</samp>. When you turn it off, the
                     statistics collected reflect default values.</li>

                  <li class="li">Pivotal recommends that you implement the Analyzer to return an estimated
                     result as fast as possible.</li>

               </ul>

            </div>

            <p class="p">The class needs to extend <samp class="ph codeph">com.pivotal.pxf.api.Analyzer</samp>.</p>

         </div>

         <div class="topic nested3" id="com.pivotal.pxf.analyzers.analyzer">
            <h4 class="title topictitle4">com.pivotal.pxf.analyzers.Analyzer</h4>

            <div class="body">
               <pre class="pre codeblock">package com.pivotal.pxf.api;
import com.pivotal.pxf.api.utilities.InputData;
import com.pivotal.pxf.api.utilities.Plugin;

/*
 * Abstract class that defines getting statistics for ANALYZE.
 * getEstimatedStats returns statistics for a given path
 * (block size, number of blocks, number of tuples).
 * Used when calling ANALYZE on a PXF external table, to get 
 * table's statistics that are used by the optimizer to plan queries. 
 */
public abstract class Analyzer extends Plugin
{
	public Analyzer(InputData inputData)
	{
		super(inputData);
	}
	
	/*
	 * 'path' is the data source name (e.g, file, dir, wildcard, table name).
	 * returns the data statistics in json format.
	 * 
	 * NOTE: It is highly recommended to implement an extremely fast logic
	 * that returns *estimated* statistics. Scanning all the data for exact
	 * statistics is considered bad practice.
	 */
	public AnalyzerStats getEstimatedStats(String data) throws Exception
	{
		/* Return default values */
		return new AnalyzerStats();
	}	
}</pre>

               <p class="p"><samp class="ph codeph">getEstimatedStats</samp> creates an <samp class="ph codeph">AnalyzerStats</samp>, and
                  returns the result <samp class="ph codeph">AnalyzerStats.dataToJSON</samp>.</p>

            </div>

         </div>

         <div class="topic nested3" id="com.pivotal.pxf.api.analyzerstats">
            <h4 class="title topictitle4">com.pivotal.pxf.api.AnalyzerStats</h4>

            <div class="body">
               <pre class="pre codeblock">package com.pivotal.pxf.api;
import java.io.IOException;
import org.codehaus.jackson.map.ObjectMapper;

/*
 * AnalyzerStats is a public class that represents the size
 * information of given path.
 */
public class AnalyzerStats {
	private static final long DEFAULT_BLOCK_SIZE = 67108864L; // 64MB (in bytes)
	private static final long DEFAULT_NUMBER_OF_BLOCKS = 1L;
	private static final long DEFAULT_NUMBER_OF_TUPLES = 1000000L;
	
	private long	blockSize;		// block size (in bytes)	
	private long	numberOfBlocks;	// number of blocks
	private long    numberOfTuples; // number of tuples
	
	public AnalyzerStats(long blockSize,
                         long numberOfBlocks,
                         long numberOfTuples)
	{
		this.setBlockSize(blockSize);
		this.setNumberOfBlocks(numberOfBlocks);
		this.setNumberOfTuples(numberOfTuples);
	}
		
	/*
	 * Default values
	 */
	public AnalyzerStats()
	{
		this(DEFAULT_BLOCK_SIZE, DEFAULT_NUMBER_OF_BLOCKS, DEFAULT_NUMBER_OF_TUPLES);
	}
	
	/*
	 * Given a AnalyzerStats, serialize it in JSON to be used as
	 * the result string for HAWQ. An example result is as follows:
	 *
	 * {"PXFDataSourceStats":{"blockSize":67108864,"numberOfBlocks":1,"numberOfTuples":5}}
	 */
	public static String dataToJSON(AnalyzerStats stats) throws IOException
	{
		ObjectMapper	mapper	= new ObjectMapper();
        // mapper serializes all members of the class by default
        return "{\"PXFDataSourceStats\":" + mapper.writeValueAsString(stats) + "}";
    }
    /*
     * Given a stats structure, convert it to be readable. Intended
     * for debugging purposes only. 'datapath' is the data path part of
     * the original URI (e.g., table name, *.csv, etc).
     */
    public static String dataToString(AnalyzerStats stats, String datapath) {
        return "Statistics information for \"" + datapath + "\" " +
                " Block Size: " + stats.blockSize +
                ", Number of blocks: " + stats.numberOfBlocks +
                ", Number of tuples: " + stats.numberOfTuples;
    }
    public long getBlockSize() {
		return blockSize;
	}
	private void setBlockSize(long blockSize) {
		this.blockSize = blockSize;
	}
	public long getNumberOfBlocks() {
		return numberOfBlocks;
	}
	private void setNumberOfBlocks(long numberOfBlocks) {
		this.numberOfBlocks = numberOfBlocks;
	}
	public long getNumberOfTuples() {
		return numberOfTuples;
	}
	private void setNumberOfTuples(long numberOfTuples) {
		this.numberOfTuples = numberOfTuples;
	}	
}    </pre>

            </div>

         </div>

      </div>

   </div>

   <div class="topic nested1" id="aboutcustomprofiles">
      <h2 class="title topictitle2">About Custom Profiles</h2>

      <div class="body">
         <p class="p">Administrators can add new profiles or edit the built-in profiles
               in <samp class="ph codeph">pxf-profiles.xml</samp> file. You need to apply the changes using ICM
            reconfigure.  All PXF users can use the profiles in
            <samp class="ph codeph">pxf-profiles.xml</samp>.</p>

         <p class="p">Each profile has a mandatory unique name, and an optional description.</p>

         <p class="p">In addition, each profile contains a set of plugins that are an extensible set of
            metadata attributes.</p>

         <div class="section"><h3 class="title sectiontitle">Custom Profile Example</h3>
            
            <pre class="pre codeblock">&lt;profile&gt;
	&lt;name&gt;MyCustomProfile&lt;/name&gt;
    &lt;description&gt;A Custom Profile Example&lt;/description&gt;
    &lt;plugins&gt;
    	&lt;fragmenter&gt;package.name.CustomProfileFragmenter&lt;/fragmenter&gt;
        &lt;accessor&gt;package.name.CustomProfileAccessor&lt;/accessor&gt;
        &lt;customPlugin1&gt;package.name.MyCustomPluginValue1&lt;/customPlugin1&gt;
		&lt;customPlugin2&gt;package.name.MyCustomPluginValue2&lt;/customPlugin2&gt;
    &lt;/plugins&gt;
&lt;/profile&gt;</pre>

         </div>

      </div>

   </div>

   <div class="topic nested1" id="aboutqueryfilterpush-down">
      <h2 class="title topictitle2">About Query Filter Push-Down</h2>

      <div class="body">
         <p class="p">If a query includes a number of WHERE clause filters,  HAWQ may push all or some queries
            to PXF. If pushed to PXF, the Accessor can use the filtering information when accessing
            the data source to fetch tuples. These filters only return records that pass filter
            evaluation conditions. This reduces data processing and reduces network traffic from the
            SQL engine.</p>

         <p class="p">This topic includes the following information:</p>

         <ul class="ul">
            <li class="li">Filter Availability and Ordering </li>

            <li class="li">Creating a Filter Builder class</li>

            <li class="li">Filter Operations</li>

            <li class="li">Sample Implementation</li>

            <li class="li">Using Filters</li>

         </ul>

      </div>

      <div class="topic nested2" id="filteravailabilityandordering">
         <h3 class="title topictitle3">Filter Availability and Ordering</h3>

         <div class="body">
            <p class="p">PXF allows push-down filtering if the following rules are met:</p>

            <ul class="ul" id="filteravailabilityandordering__ul_whz_hvz_4p">
               <li class="li">Uses only single expressions or a group of AND'ed expressions - no OR'ed
                  expressions.</li>

               <li class="li">Uses only expressions of supported data types and operators. See  <a class="xref" href="PXFInstallationandAdministration.html">PXF Installation and Administration</a> for more information.</li>

            </ul>

            <p class="p">FilterParser scans the pushed down filter list and uses the user's build()
               implementation to build the filter. </p>

            <ul class="ul" id="filteravailabilityandordering__ul_vjz_hvz_4p">
               <li class="li">For simple expressions (e.g, a &gt;= 5), FilterParser places column objects on
                  the left of the expression and constants on the right. </li>

               <li class="li">For compound expressions (e.g &lt;expression&gt; AND &lt;expression&gt;) it
                  handles three cases in the build() function: <ol class="ol" id="filteravailabilityandordering__ol_xlz_hvz_4p">
                     <li class="li">Simple Expression: &lt;Column Index&gt; &lt;Operation&gt;
                        &lt;Constant&gt;</li>

                     <li class="li">Compound Expression: &lt;Filter Object&gt; AND &lt;Filter Object&gt;</li>

                     <li class="li">Compound Expression: &lt;List of Filter Objects&gt; AND &lt;Filter
                        Object&gt;</li>

                  </ol>
</li>

            </ul>

         </div>

      </div>

      <div class="topic nested2" id="creatingafilterbuilderclass">
         <h3 class="title topictitle3">Creating a Filter Builder Class</h3>

         <div class="body">
            <p class="p p2">To check if a filter queried PXF, call the <samp class="ph codeph">InputData
                  hasFilter()</samp> function:</p>

            <pre class="pre codeblock"> /*
  * Returns true if there is a filter string to parse
  */
 public boolean hasFilter()
 {
     return filterStringValid;
 }</pre>

            <p class="p p1">If <samp class="ph codeph">hasFilter()</samp> returns <samp class="ph codeph">false</samp>,
               there is no filter information. If it returns <samp class="ph codeph">true</samp>, PXF parses the
               serialized filter string into a meaningful filter object to use later. To do so,
               create a filter builder class that implements
                  the <samp class="ph codeph">FilterParser.FilterBuilder </samp> interface:</p>

            <pre class="pre codeblock"> /*
  * Interface a user of FilterParser should implement
  * This is used to let the user build filter expressions in the manner she 
  * sees fit
  *
  * When an operator is parsed, this function is called to let the user decide
  * what to do with it operands.
  */
 interface FilterBuilder {
     public Object build(Operation operation, Object left, Object right) throws Exception;
 }</pre>

            <p class="p">While PXF parses the serialized filter string from the incoming HAWQ query, it calls
               the <samp class="ph codeph">build() interface</samp> function. PXF calls this function for each
               condition or filter pushed down to PXF. Implementing this function returns some
               Filter object or representation that the Accessor or Resolver uses in runtime to
               filter out records. The <samp class="ph codeph">build()</samp> function accepts an Operation as
               input, and left and right operands.</p>

         </div>

      </div>

      <div class="topic nested2" id="filteroperations">
         <h3 class="title topictitle3">Filter Operations</h3>

         <div class="body">
            <pre class="pre codeblock"> /*
  * Operations supported by the parser
  */
 public enum Operation
 {
     HDOP_LT, //less than
     HDOP_GT, //greater than
     HDOP_LE, //less than or equal
     HDOP_GE, //greater than or equal
     HDOP_EQ, //equal
     HDOP_NE, //not equal
     HDOP_AND //AND'ed conditions
 };</pre>

         </div>

         <div class="topic nested3" id="filteroperands">
            <h4 class="title topictitle4">Filter Operands</h4>

            <div class="body">
               <p class="p">There are three types of operands:</p>

               <ul class="ul" id="filteroperands__ul_xsq_2vz_4p">
                  <li class="li">Column Index</li>

                  <li class="li">Constant</li>

                  <li class="li">Filter Object</li>

               </ul>

            </div>

         </div>

         <div class="topic nested3" id="columnindex">
            <h4 class="title topictitle4">Column Index</h4>

            <div class="body">
               <pre class="pre codeblock"> /*
  * The class represents a column index
  * It used to know the type of an operand in the stack
  */
 public class ColumnIndex
 {
     private int index;
     
     public ColumnIndex(int idx)
     {
         index = idx;
     }
 
     public int index()
     {
         return index;
     }
 }</pre>

            </div>

         </div>

         <div class="topic nested3" id="constant">
            <h4 class="title topictitle4">Constant</h4>

            <div class="body">
               <pre class="pre codeblock"> /*
  * The class represents a constant object (String, Long, ...)
  * It used to know the type of an operand in the stack
  */
 public class Constant
 {
      private Object constant;

      public Constant(Object obj)
      {
          constant = obj;
      }
 
      public Object constant()
      {
          return constant;
      }
 }</pre>

            </div>

         </div>

         <div class="topic nested3" id="filterobject">
            <h4 class="title topictitle4">Filter Object</h4>

            <div class="body">
               <p class="p">Filter Objects can be internal, such as those you define; or external, those that
                  the remote system uses. For example, for HBase, you define the
                     HBase <samp class="ph codeph">Filter </samp>class
                     (<samp class="ph codeph">org.apache.hadoop.hbase.filter.Filter</samp>), while for Hive, you
                  use an internal default representation created by the PXF framework,
                     called <samp class="ph codeph">BasicFilter </samp>. You can decide the filter object to use,
                  including writing a new one. <samp class="ph codeph">BasicFilter</samp> is the most common:</p>

               <pre class="pre codeblock"> /*
  * Basic filter provided for cases where the target storage system does not provide its own filter
  * For example: Hbase storage provides its own filter but for a Writable based record in a SequenceFile
  * there is no filter provided and so we need to have a default
  */
 static public class BasicFilter
 {
     private Operation oper;
     private ColumnIndex column;
     private Constant constant;
 
     /*
      * C'tor
      */
     public BasicFilter(Operation inOper, ColumnIndex inColumn, Constant inConstant)
     {
         oper = inOper;
         column = inColumn;
         constant = inConstant;
     }
 
     /*
      * returns oper field
      */
     public Operation getOperation()
     {
         return oper;
     }
 
     /*
      * returns column field
      */
     public ColumnIndex getColumn()
     {
         return column;
     }
 
     /*
      * returns constant field
      */
     public Constant getConstant()
     {
         return constant;
     }
 }</pre>

            </div>

         </div>

      </div>

      <div class="topic nested2" id="sampleimplementation">
         <h3 class="title topictitle3">Sample Implementation</h3>

         <div class="body">
            <p class="p">Let's look at the following sample implementation of the filter builder class and its
                  <samp class="ph codeph">build()</samp> function that handles all 3 cases. Let's assume that
               BasicFilter was used to hold our filter operations</p>

            <pre class="pre codeblock">public class MyDemoFilterBuilder implements FilterParser.FilterBuilder
{
	private InputData inputData;

	public MyDataFilterBuilder(InputData input)
	{
		inputData = input;
	}

	/*
	 * Translates a filterString into a FilterParser.BasicFilter or a list of such filters
	 */
	public Object getFilterObject(String filterString) throws Exception
	{
		FilterParser parser = new FilterParser(this);
		Object result = parser.parse(filterString);

		if (!(result instanceof FilterParser.BasicFilter) &amp;&amp; !(result instanceof List))
			throw new Exception("String " + filterString + " resolved to no filter");

		return result;
	}
 
	public Object build(FilterParser.Operation opId, 
						Object leftOperand, 
						Object rightOperand) throws Exception
	{
		if (leftOperand instanceof FilterParser.BasicFilter)
		{
			//sanity check
			if (opId != FilterParser.Operation.HDOP_AND || !(rightOperand instanceof FilterParser.BasicFilter))
				throw new Exception("Only AND is allowed between compound expressions");

			//case 3
			if (leftOperand instanceof List)
				return handleCompoundOperations((List&lt;FilterParser.BasicFilter&gt;)leftOperand, (FilterParser.BasicFilter)rightOperand);
			//case 2
			else 
				return handleCompoundOperations((FilterParser.BasicFilter)leftOperand, (FilterParser.BasicFilter)rightOperand);
		}

		//sanity check
		if (!(rightOperand instanceof FilterParser.Constant))
			throw new Exception("expressions of column-op-column are not supported");

		//case 1 (assume column is on the left)
		return handleSimpleOperations(opId, (FilterParser.ColumnIndex)leftOperand, (FilterParser.Constant)rightOperand);
	}

	private FilterParser.BasicFilter handleSimpleOperations(FilterParser.Operation opId,
															FilterParser.ColumnIndex column,
															FilterParser.Constant constant)
	{
		return new FilterParser.BasicFilter(opId, column, constant);
	}

	private  List handleCompoundOperations(List&lt;FilterParser.BasicFilter&gt; left, 
									   FilterParser.BasicFilter right)
	{
		left.add(right);
		return left;
	}

	private List handleCompoundOperations(FilterParser.BasicFilter left, 
										  FilterParser.BasicFilter right)
	{
		List&lt;FilterParser.BasicFilter&gt; result = new LinkedList&lt;FilterParser.BasicFilter&gt;();

	 	result.add(left);
		result.add(right);
		return result;
	}
}</pre>

            <p class="p">Here is an example of creating a filter-builder class to implement the Filter
               interface, implement the <samp class="ph codeph">build()</samp> function, and generate the Filter
               object. To do this, use either the Accessor, Resolver, or both to call the
                  <samp class="ph codeph">getFilterObject</samp> function:</p>

            <pre class="pre codeblock">if (inputData.hasFilter())
{
	String filterStr = inputData.filterString();
	DemoFilterBuilder demobuilder = new DemoFilterBuilder(inputData);
	Object filter = demobuilder.getFilterObject(filterStr);
	...
}</pre>

         </div>

      </div>

      <div class="topic nested2" id="usingfilters">
         <h3 class="title topictitle3">Using Filters</h3>

         <div class="body">
            <p class="p">Once you have built the FIlter object(s), you can use them to read data and filter
               out records that do not meet the filter conditions:</p>

            <ol class="ol" id="usingfilters__ol_r4x_hvz_4p">
               <li class="li">Check whether you have a single or multiple filters.</li>

               <li class="li">Evaluate each filter and iterate over each filter in the list. Disqualify the
                  record if filter conditions fail.</li>

            </ol>

            <pre class="pre codeblock">if (filter instanceof List)
{
	for (Object f : (List)filter)
		&lt;evaluate f&gt;; //may want to break if evaluation results in negative answer for any filter.
}
else
{
	&lt;evaluate filter&gt;;
}</pre>

            <p class="p">Example of evaluating a single filter:</p>

            <pre class="pre codeblock">//Get our BasicFilter Object
FilterParser.BasicFilter bFilter = (FilterParser.BasicFilter)filter;

 
//Get operation and operator values
FilterParser.Operation op = bFilter.getOperation(); 
int colIdx = bFilter.getColumn().index();
String val = bFilter.getConstant().constant().toString();

//Get more info about the column if desired
ColumnDescriptor col = input.getColumn(colIdx);
String colName = filterColumn.columnName();
 
//Now evaluate it against the actual column value in the record...</pre>

         </div>

      </div>

   </div>

   <div class="topic nested1" id="reference">
      <h2 class="title topictitle2">Reference</h2>

      <div class="body">
         <p class="p">This section contains the following information:</p>

         <ul class="ul">
            <li class="li">External Table Samples</li>

            <li class="li">Plugin Examples</li>

            <li class="li">Configuration Files</li>

         </ul>

      </div>

      <div class="topic nested2" id="externaltableexamples">
         <h3 class="title topictitle3">External Table Examples</h3>

         <div class="topic nested3" id="example1">
            <h4 class="title topictitle4">Example 1</h4>

            <div class="body">
               <p class="p">Shows an external table that can analyze all <samp class="ph codeph">Sequencefiles </samp>that
                  are populated <samp class="ph codeph">Writable </samp>serialized records and exist inside the
                  hdfs directory <samp class="ph codeph">sales/2012/01</samp>. <samp class="ph codeph">SaleItem.class</samp> is
                  a Java class that implements the <samp class="ph codeph">Writable </samp>interface and describes
                  a Java record that includes three class members.</p>

               <div class="note note"><span class="notetitle">Note:</span> In this example, the class member names do not necessarily match the database
                  attribute names, but the types match. <samp class="ph codeph">SaleItem.class</samp> must exist
                  in the classpath of every
                  Datanode.<pre class="pre codeblock">CREATE EXTERNAL TABLE jan_2012_sales (id int, total int, comments varchar) 
LOCATION ('pxf://10.76.72.26:50070/sales/2012/01/*.seq?FRAGMENTER=com.pivotal.pxf.plugins.hdfs.HdfsDataFragmenter&amp;ACCESSOR=com.pivotal.pxf.plugins.hdfs.SequenceFileAccessor&amp;RESOLVER=com.pivotal.pxf.plugins.hdfs.WritableResolver&amp;DATA-SCHEMA=SaleItem')
FORMAT ‘custom’ (formatter='pxfwritable_import');</pre>
</div>

            </div>

         </div>

         <div class="topic nested3" id="example2">
            <h4 class="title topictitle4">Example 2</h4>

            <div class="body">
               <p class="p">Example 2 shows an external table that can analyze an HBase table called<samp class="ph codeph">
                     sales</samp>. It has 10 column families <samp class="ph codeph">(cf1 – cf10)</samp> and
                  many qualifier names in each family. This example focuses on the
                     <samp class="ph codeph">rowkey</samp>, the qualifier<samp class="ph codeph"> saleid</samp> inside column
                  family <samp class="ph codeph">cf1</samp>, and the qualifier <samp class="ph codeph">comments</samp> inside
                  column family <samp class="ph codeph">cf8</samp> and uses Direct Mapping:</p>

               <pre class="pre codeblock">CREATE EXTERNAL TABLE hbase_sales (hbaserowkey text, "cf1:saleid" int, "cf8:comments" varchar)
LOCATION
('pxf://10.76.72.26:50070/sales?PROFILE=HBase')
FORMAT ‘custom’ (formatter='pxfwritable_import');</pre>

            </div>

         </div>

         <div class="topic nested3" id="example3">
            <h4 class="title topictitle4">Example 3</h4>

            <div class="body">
               <p class="p">This example uses Indirect Mapping. Note how the attribute name changes and how
                  they correspond to the HBase lookup table. Executing a <samp class="ph codeph">SELECT from
                     my_hbase_sales</samp>, the attribute names automatically convert to their
                  HBase correspondents.</p>

               <pre class="pre codeblock">CREATE EXTERNAL TABLE my_hbase_sales (hbaserowkey text, id int, cmts varchar) 
LOCATION
('pxf://10.76.72.26:8080/sales?PROFILE=HBase')
FORMAT ‘custom’ (formatter='pxfwritable_import');</pre>

            </div>

         </div>

         <div class="topic nested3" id="example4">
            <h4 class="title topictitle4">Example 4</h4>

            <div class="body">
               <p class="p">Shows an example for a writable table of compressed data. </p>

               <pre class="pre codeblock">CREATE WRITABLE EXTERNAL TABLE sales_aggregated_2012 (id int, total int, comments varchar) 
LOCATION
('pxf://10.76.72.26:8080/sales/2012/aggregated?PROFILE=HdfsTextSimple&amp;COMPRESSION_CODEC=org.apache.hadoop.io.compress.BZip2Codec')
FORMAT ‘TEXT’;</pre>

            </div>

         </div>

         <div class="topic nested3" id="example5">
            <h4 class="title topictitle4">Example 5</h4>

            <div class="body">
               <p class="p">Shows an example for writable table into sequence file, using schema file. Note
                  that for write, the formatter is <samp class="ph codeph">pxfwritable_export.</samp>
               </p>

               <pre class="pre codeblock">CREATE WRITABLE EXTERNAL TABLE sales_max_2012 (id int, total int, comments varchar) 
LOCATION
('pxf://10.76.72.26:8080/sales/2012/max?FRAGMENTER=com.pivotal.pxf.plugins.hdfs.HdfsDataFragmenter&amp;ACCESSOR=com.pivotal.pxf.plugins.hdfs.SequenceFileAccessor&amp;RESOLVER=com.pivotal.pxf.plugins.hdfs.WritableResolver&amp;DATA-SCHEMA=SaleItem')
FORMAT ‘custom’ (formatter='pxfwritable_export');</pre>

            </div>

         </div>

      </div>

      <div class="topic nested2" id="pluginexamples">
         <h3 class="title topictitle3">Plugin Examples</h3>

         <div class="body">
            <p class="p">This section contains sample dummy implantations of all four plug-ins. It also
               contains a usage example.</p>

         </div>

         <div class="topic nested3" id="dummyfragmenter">
            <h4 class="title topictitle4">Dummy Fragmenter</h4>

            <div class="body">
               <pre class="pre codeblock">import com.pivotal.pxf.api.Fragmenter;
import com.pivotal.pxf.api.Fragment;
import com.pivotal.pxf.api.utilities.InputData;
import java.util.List;

/*
 * Class that defines the splitting of a data resource into fragments that can
 * be processed in parallel
 * getFragments() returns the fragments information of a given path (source name and location of each fragment).
 * Used to get fragments of data that could be read in parallel from the different segments.
 * Dummy implementation, for documentation
 */
public class DummyFragmenter extends Fragmenter {
    public DummyFragmenter(InputData metaData) {
        super(metaData);
    }
    /*
     * path is a data source URI that can appear as a file name, a directory name  or a wildcard
     * returns the data fragments - identifiers of data and a list of available hosts
     */
    @Override
    public List&lt;Fragment&gt; getFragments() throws Exception {
        String localhostname = java.net.InetAddress.getLocalHost().getHostName();
        String[] localHosts = new String[]{localhostname, localhostname};
        fragments.add(new Fragment(inputData.dataSource() + ".1" /* source name */,
                localHosts /* available hosts list */,
                "fragment1".getBytes()));
        fragments.add(new Fragment(inputData.dataSource() + ".2" /* source name */,
                localHosts /* available hosts list */,
                "fragment2".getBytes()));
        fragments.add(new Fragment(inputData.dataSource() + ".3" /* source name */,
                localHosts /* available hosts list */,
                "fragment3".getBytes()));
        return fragments;
    }
}</pre>

            </div>

         </div>

         <div class="topic nested3" id="dummyaccessor">
            <h4 class="title topictitle4">Dummy Accessor</h4>

            <div class="body">
               <pre class="pre codeblock">import com.pivotal.pxf.api.ReadAccessor;
import com.pivotal.pxf.api.WriteAccessor;
import com.pivotal.pxf.api.OneRow;
import com.pivotal.pxf.api.utilities.InputData;
import com.pivotal.pxf.api.utilities.Plugin;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/*
 * Internal interface that defines the access to a file on HDFS.  All classes
 * that implement actual access to an HDFS file (sequence file, avro file,...)
 * must respect this interface
 * Dummy implementation, for documentation
 */
public class DummyAccessor extends Plugin implements ReadAccessor, WriteAccessor {
    private static final Log LOG = LogFactory.getLog(DummyAccessor.class);
    private int rowNumber;
    private int fragmentNumber;
    public DummyAccessor(InputData metaData) {
        super(metaData);
    }
    @Override
    public boolean openForRead() throws Exception {
        /* fopen or similar */
        return true;
    }
    @Override
    public OneRow readNextObject() throws Exception {
        /* return next row , &lt;key=fragmentNo.rowNo, val=rowNo,text,fragmentNo&gt;*/
        /* check for EOF */
        if (fragmentNumber &gt; 0)
            return null; /* signal EOF, close will be called */
        int fragment = inputData.getDataFragment();
        String fragmentMetadata = new String(inputData.getFragmentMetadata());
        /* generate row */
        OneRow row = new OneRow(fragment + "." + rowNumber, /* key */
                rowNumber + "," + fragmentMetadata + "," + fragment /* value */);
        /* advance */
        rowNumber += 1;
        if (rowNumber == 2) {
            rowNumber = 0;
            fragmentNumber += 1;
        } 
        /* return data */
        return row;
    }
    @Override
    public void closeForRead() throws Exception {
        /* fclose or similar */
    }
    @Override
    public boolean openForWrite() throws Exception {
        /* fopen or similar */
        return true;
    }
    @Override
    public boolean writeNextObject(OneRow onerow) throws Exception {
        LOG.info(onerow.getData());
        return true;
    }
    @Override
    public void closeForWrite() throws Exception {
        /* fclose or similar */
    }
}</pre>

            </div>

         </div>

         <div class="topic nested3" id="dummyresolver">
            <h4 class="title topictitle4">Dummy Resolver</h4>

            <div class="body">
               <pre class="pre codeblock">import com.pivotal.pxf.api.OneField;
import com.pivotal.pxf.api.OneRow;
import com.pivotal.pxf.api.ReadResolver;
import com.pivotal.pxf.api.WriteResolver;
import com.pivotal.pxf.api.utilities.InputData;
import com.pivotal.pxf.api.utilities.Plugin;
import java.util.LinkedList;
import java.util.List;
import static com.pivotal.pxf.api.io.DataType.INTEGER;
import static com.pivotal.pxf.api.io.DataType.VARCHAR;

/*
 * Class that defines the deserializtion of one record brought from the external input data.
 * Every implementation of a deserialization method (Writable, Avro, BP, Thrift, ...)
 * must inherit this abstract class
 * Dummy implementation, for documentation
 */
public class DummyResolver extends Plugin implements ReadResolver, WriteResolver {
    private int rowNumber;
    public DummyResolver(InputData metaData) {
        super(metaData);
        rowNumber = 0;
    }
    @Override
    public List&lt;OneField&gt; getFields(OneRow row) throws Exception {
        /* break up the row into fields */
        List&lt;OneField&gt; output = new LinkedList&lt;OneField&gt;();
        String[] fields = ((String) row.getData()).split(",");
        output.add(new OneField(INTEGER.getOID() /* type */, Integer.parseInt(fields[0]) /* value */));
        output.add(new OneField(VARCHAR.getOID(), fields[1]));
        output.add(new OneField(INTEGER.getOID(), Integer.parseInt(fields[2])));
        return output;
    }
    @Override
    public OneRow setFields(List&lt;OneField&gt; record) throws Exception {
        /* should read inputStream row by row */
        return rowNumber &gt; 5
                ? null
                : new OneRow(null, "row number " + rowNumber++);
    }
}</pre>

            </div>

         </div>

         <div class="topic nested3" id="dummyanalyzer">
            <h4 class="title topictitle4">Dummy Analyzer</h4>

            <div class="body">
               <pre class="pre codeblock">import com.pivotal.pxf.api.AnalyzerStats;
import com.pivotal.pxf.api.ReadAccessor;
import com.pivotal.pxf.api.Analyzer;
import com.pivotal.pxf.api.utilities.InputData;

/*
 * Class that defines getting statistics for ANALYZE.
 * getEstimatedStats returns statistics for a given path
 * (block size, number of blocks, number of tuples).
 * Used when calling ANALYZE on a GPXF external table,
 * to get table's statistics that are used by the optimizer to plan queries. 
 * Dummy implementation, for documentation
 */
public class DummyAnalyzer extends Analyzer {
    public DummyAnalyzer(InputData metaData) {
        super(metaData);
    }

    /*
     * path is a data source URI that can appear as a file name, a directory name or a wildcard
     * returns the data statistics in json format
     */
    @Override
    public AnalyzerStats getEstimatedStats(String data) throws Exception {
        return new AnalyzerStats(160000 /* disk block size in bytes */,
                3 /* number of disk blocks */,
                6 /* total number of rows */);
    }
} </pre>

            </div>

         </div>

         <div class="topic nested3" id="usageexample">
            <h4 class="title topictitle4">Usage Example</h4>

            <div class="body">
               <pre class="pre codeblock">psql=# CREATE EXTERNAL TABLE dummy_tbl (int1 integer, word text, int2 integer)
location
('pxf://localhost:50070/dummy_location?FRAGMENTER=DummyFragmenter&amp;ACCESSOR=DummyAccessor&amp;RESOLVER=DummyResolver&amp;ANALYZER=DummyAnalyzer') format'custom' (formatter = 'pxfwritable_import');
　
CREATE EXTERNAL TABLE
psql=# SELECT * FROM dummy_tbl;
int1 | word | int2
------+------+------
0 | fragment1 | 0
1 | fragment1 | 0
0 | fragment2 | 0
1 | fragment2 | 0
0 | fragment3 | 0
1 | fragment3 | 0
(6 rows)
psql=# CREATE WRITABLE EXTERNAL TABLE dummy_tbl_write (int1 integer, word text, int2 integer)
location
('pxf://localhost:50070/dummy_location?ACCESSOR=DummyAccessor&amp;RESOLVER=DummyResolver') 
format'custom' (formatter = 'pxfwritable_import');
　
CREATE EXTERNAL TABLE
psql=# INSERT INTO dummy_tbl_write VALUES (1, 'a', 11), (2, 'b', 22);
INSERT 0 2</pre>

            </div>

         </div>

      </div>

      <div class="topic nested2" id="configurationfiles">
         <h3 class="title topictitle3">Configuration Files</h3>

         <div class="body">
            <p class="p">This section contains sample environment variable files for HDFS, HIVE, and
               HBase:</p>

         </div>

      </div>

      <div class="topic nested2" id="hadoop-env.sh">
         <h3 class="title topictitle3">hadoop-env.sh</h3>

         <div class="body">
            <p class="p">You can use this file to configure the following types of configurations:</p>

            <ul class="ul" id="hadoop-env.sh__ul_fxb_5vz_4p">
               <li class="li">HDFS only</li>

               <li class="li">HDFS and HBase</li>

               <li class="li">HDFS, HBase, and Hive</li>

            </ul>

         </div>

         <div class="topic nested3" id="hdfsonly">
            <h4 class="title topictitle4">HDFS only</h4>

            <div class="body">
               <pre class="pre codeblock">export GPHD_ROOT=/usr/lib/gphd
export HADOOP_CLASSPATH=\
$GPHD_ROOT/pxf/pxf-core.jar:\
$GPHD_ROOT/pxf/pxf-api.jar:\
$GPHD_ROOT/publicstage:\</pre>

            </div>

         </div>

         <div class="topic nested3" id="hdfsandhbase">
            <h4 class="title topictitle4">HDFS and HBase</h4>

            <div class="body">
               <pre class="pre codeblock">export GPHD_ROOT=/usr/lib/gphd
export HADOOP_CLASSPATH=\
$GPHD_ROOT/pxf/pxf-core.jar:\
$GPHD_ROOT/pxf/pxf-api.jar:\
$GPHD_ROOT/publicstage:\
$GPHD_ROOT/zookeeper/zookeeper-3.4.5-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/hbase-common-0.96.0-hadoop2-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/hbase-protocol-0.96.0-hadoop2-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/hbase-client-0.96.0-hadoop2-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/hbase-thrift-0.96.0-hadoop2-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/htrace-core-2.01.jar:\
/etc/gphd/hbase/conf:\</pre>

            </div>

         </div>

         <div class="topic nested3" id="hdfshbaseandhive">
            <h4 class="title topictitle4">HDFS, HBase, and Hive</h4>

            <div class="body">
               <pre class="pre codeblock">export GPHD_ROOT=/usr/lib/gphd
export HADOOP_CLASSPATH=\
$GPHD_ROOT/pxf/pxf-core.jar:\
$GPHD_ROOT/pxf/pxf-api.jar:\
$GPHD_ROOT/publicstage:\
$GPHD_ROOT/zookeeper/zookeeper-3.4.5-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/hbase-common-0.96.0-hadoop2-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/hbase-protocol-0.96.0-hadoop2-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/hbase-client-0.96.0-hadoop2-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/hbase-thrift-0.96.0-hadoop2-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hbase/lib/htrace-core-2.01.jar:\
/etc/gphd/hbase/conf:\
$GPHD_ROOT/hive/lib/hive-service-0.12.0-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hive/lib/hive-metastore-0.12.0-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hive/lib/hive-common-0.12.0-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hive/lib/hive-exec-0.12.0-gphd-3.0.0.0.jar:\
$GPHD_ROOT/hive/lib/libfb303-0.9.0.jar:\
$GPHD_ROOT/hive/lib/libthrift-0.9.0.jar:\</pre>

            </div>

         </div>

      </div>

      <div class="topic nested2" id="hbase-site.xml">
         <h3 class="title topictitle3">hbase-site.xml</h3>

         <div class="body">
            <p class="p">You can use this file to configure the following types of configurations:</p>

            <ul class="ul" id="hbase-site.xml__ul_lnb_5vz_4p">
               <li class="li">HBase</li>

               <li class="li">HDFS, HBase and Hive</li>

            </ul>

         </div>

         <div class="topic nested3" id="hbase">
            <h4 class="title topictitle4">HBase</h4>

            <div class="body">
               <p class="p">The Java Class path requires the PXF JAR filse.
                     <span class="ph filepath">hbase-site.xml</span> needs to be configured to match the hbase
                  settings on all nodes (Namenode and Datanodes).</p>

            </div>

         </div>

      </div>

   </div>

   <div class="topic nested1" id="credentialsforremoteservices">
      <h2 class="title topictitle2">Credentials for Remote Services</h2>

      <div class="body">
         <p class="p">Credentials for remote services allows a PXF plugin to access a remote service that
            requires credentials.</p>

      </div>

      <div class="topic nested2" id="inhawq">
         <h3 class="title topictitle3">In HAWQ</h3>

         <div class="body">
            <p class="p">For these credentials, we implemented two GUCs in HAWQ:</p>

            <ol class="ol" id="inhawq__ol_osf_yvz_4p">
               <li class="li">pxf_remote_service_login - a string of characters detailing information regarding
                  login (i.e. user name).</li>

               <li class="li">pxf_remote_service_secret - a string of characters detailing information that is
                  considered secret (i.e. password).</li>

            </ol>

            <p class="p">Currently, we store the contents of the two GUCs in memory, without any security, for
               the whole session. Leaving the session will insecurely drop the GUCs' contents.</p>

            <div class="note important"><span class="importanttitle">Important:</span> These GUCs are temporary and could soon be marked deprecated, in
               favor of a complete solution for managing credentials for remote services in
               PXF.</div>

         </div>

      </div>

      <div class="topic nested2" id="inapxfplugin">
         <h3 class="title topictitle3">In a PXF Plugin</h3>

         <div class="body">
            <p class="p">As a PXF plugin, the content of the two GUCs is available through the following
               InputData API functions:</p>

            <ol class="ol" id="inapxfplugin__ol_x3f_yvz_4p">
               <li class="li">string getLogin()</li>

               <li class="li">string getSecret()</li>

            </ol>

            <p class="p">Both functions will return 'null' if the corresponding HAWQ GUC was set to an empty
               string or wasn't set at all. </p>

         </div>

      </div>

   </div>

<div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../topics/PivotalExtensionFrameworkPXF.html" title="Pivotal Extension Framework (PXF)"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">Pivotal Extension Framework (PXF)</span></a></span>  </div><div>
<div class="container">
  <footer class="site-footer-links">
    <div class="copyright">
      <a href="http://docs.pivotal.io" target="_blank">Pivotal Documentation</a>
      © 2014 <a href="http://www.pivotal.io/" target="_blank">Pivotal Software</a>, Inc. All Rights Reserved.
  </div>
  <div class="support">
    Need help? <a href="http://support.pivotal.io" target="_blank">Visit Support</a>
   </div>
  </footer>
</div><!--end of container-->
</div>
</body>
</html>