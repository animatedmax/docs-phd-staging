
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head><meta xmlns="http://www.w3.org/1999/xhtml" name="description" content="Defines a new table. Synopsis CREATE [[GLOBAL | LOCAL] {TEMPORARY | TEMP}] TABLE table_name ( [ { column_name data_type [ DEFAULT default_expr ]    [column_constraint [ ... ] [ ENCODING ( ..."/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="copyright" content="(C) Copyright 2005"/><meta name="DC.rights.owner" content="(C) Copyright 2005"/><meta name="DC.Type" content="topic"/><meta name="DC.Title" content="CREATE TABLE"/><meta name="DC.Relation" scheme="URI" content="../hawq-topics/SQLCommandReference.html"/><meta name="prodname" content=""/><meta name="version" content="2.1.0"/><meta name="release" content=""/><meta name="modification" content=""/><meta name="DC.Format" content="XHTML"/><meta name="DC.Identifier" content="topic1"/><link rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>CREATE TABLE</title><meta xmlns="http://www.w3.org/1999/xhtml" http-equiv="Content-Type" content="text/html; charset=utf-8"><!----></meta><link xmlns="http://www.w3.org/1999/xhtml" rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/commonltr.css"><!----></link><link xmlns="http://www.w3.org/1999/xhtml" rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../oxygen-webhelp/resources/css/pivotal.css"/><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript"><!--
          
          var prefix = "../index.html";
          
          --></script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" src="../oxygen-webhelp/resources/js/jquery-1.8.2.min.js"><!----></script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" src="../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" src="../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" charset="utf-8" src="../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script></head>
<body onload="highlightSearchTerm()" id="topic1"><script xmlns="http://www.w3.org/1999/xhtml" src="//use.typekit.net/clb0qji.js" type="text/javascript"/><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
			  try {
				  Typekit.load();
			  } catch (e) {
			  }
		  </script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
			  document.domain = "pivotal.io";
		  </script><script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
			WebFontConfig = {
			  google: { families: [ 'Source+Sans+Pro:300italic,400italic,300,400,600:latin' ] }
			};
			(function() {
			  var wf = document.createElement('script');
			  wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
				'://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
			  wf.type = 'text/javascript';
			  wf.async = 'true';
			  var s = document.getElementsByTagName('script')[0];
			  s.parentNode.insertBefore(wf, s);
			})();
		  </script>
<table class="nav"><tbody><tr><td colspan="2"><div id="permalink"><a href="#">linkToThis</a></div><div id="printlink"><a href="javascript:window.print();">printThisPage</a></div></td></tr><tr><td><div class="navheader">
<span class="navparent"><a class="link" href="../hawq-topics/SQLCommandReference.html" title="SQL Command Reference"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">SQL Command Reference</span></a></span>  </div></td><td width="75%"><a class="navheader_parent_path" href="../hawq-topics/../hawq-topics/HAWQAdministration.html" title="HAWQ Administration">HAWQ Administration</a> / <a class="navheader_parent_path" href="../hawq-topics/SQLCommandReference.html" title="SQL Command Reference">SQL Command Reference</a></td></tr></tbody></table>

   <h1 class="title topictitle1">CREATE TABLE</h1>

   <div class="body">
      <p class="p" id="topic1__sql_command_desc">Defines a new table.</p>

      <div class="section" id="topic1__section2"><h2 class="title sectiontitle">Synopsis</h2>
         
         <pre class="pre codeblock" id="topic1__sql_command_synopsis">CREATE [[GLOBAL | LOCAL] {TEMPORARY | TEMP}] TABLE <var class="keyword varname">table_name</var> ( 
[ { column_name data_type [ DEFAULT default_expr ] 
   [column_constraint [ ... ]
[ ENCODING ( storage_directive [,...] ) ]
] 
   | <var class="keyword varname">table_constraint</var>
   | LIKE <var class="keyword varname">other_table</var> [{INCLUDING | EXCLUDING} 
                      {DEFAULTS | CONSTRAINTS}] ...}
   [, ... ] ]
   [<var class="keyword varname">column_reference_storage_directive</var> [, …] ]
   )
   [ INHERITS ( <var class="keyword varname">parent_table</var> [, ... ] ) ]
   [ WITH ( <var class="keyword varname">storage_parameter</var>=<var class="keyword varname">value</var> [, ... ] )
   [ ON COMMIT {PRESERVE ROWS | DELETE ROWS | DROP} ]
   [ TABLESPACE <var class="keyword varname">tablespace</var> ]
   [ DISTRIBUTED BY (<var class="keyword varname">column</var>, [ ... ] ) | DISTRIBUTED RANDOMLY ]
   [ PARTITION BY <var class="keyword varname">partition_type</var> (<var class="keyword varname">column</var>)
       [ SUBPARTITION BY <var class="keyword varname">partition_type</var> (<var class="keyword varname">column</var>) ] 
          [ SUBPARTITION TEMPLATE ( <var class="keyword varname">template_spec </var>) ]
       [...]
    ( <var class="keyword varname">partition_spec</var> ) 
        | [ SUBPARTITION BY <var class="keyword varname">partition_type</var> (<var class="keyword varname">column</var>) ]
          [...]
    ( <var class="keyword varname">partition_spec</var>
      [ ( <var class="keyword varname">subpartition_spec</var>
           [(...)] 
         ) ] 
    )</pre>

         <p class="p">where <var class="keyword varname">storage_parameter</var> is:</p>

         <pre class="pre codeblock">   APPENDONLY={TRUE}
   BLOCKSIZE={8192-2097152}
   ORIENTATION={COLUMN | ROW | PARQUET}
   COMPRESSTYPE={ZLIB | QUICKLZ | SNAPPY | GZIP | NONE}
   COMPRESSLEVEL={0-9}
   FILLFACTOR={10-100}
   OIDS=[TRUE | FALSE]
   PAGESIZE={1024-1073741823}
   ROWGROUPSIZE={1024-1073741823}</pre>

         <p class="p">where <var class="keyword varname">column_constraint</var> is:</p>

         <pre class="pre codeblock">   [CONSTRAINT <var class="keyword varname">constraint_name</var>]
   NOT NULL | NULL 
   | CHECK ( <var class="keyword varname">expression</var> )</pre>

         <p class="p">and <var class="keyword varname">table_constraint</var> is:</p>

         <pre class="pre codeblock">   [CONSTRAINT <var class="keyword varname">constraint_name</var>]
   | CHECK ( <var class="keyword varname">expression</var> )</pre>

         <p class="p">where <var class="keyword varname">partition_type</var> is:</p>

         <pre class="pre codeblock">    LIST
  | RANGE</pre>

         <p class="p">where <var class="keyword varname">partition_specification</var> is:</p>

         <pre class="pre codeblock">
            <var class="keyword varname">partition_element</var> [, ...]</pre>

         <p class="p">and <var class="keyword varname">partition_element</var> is:</p>

         <pre class="pre codeblock">   DEFAULT PARTITION <var class="keyword varname">name</var>
  | [PARTITION <var class="keyword varname">name</var>] VALUES (<var class="keyword varname">list_value</var> [,...] )
  | [PARTITION <var class="keyword varname">name</var>] 
     START ([<var class="keyword varname">datatype</var>] '<var class="keyword varname">start_value</var>') [INCLUSIVE | EXCLUSIVE]
     [ END ([<var class="keyword varname">datatype</var>] '<var class="keyword varname">end_value</var>') [INCLUSIVE | EXCLUSIVE] ]
     [ EVERY ([<var class="keyword varname">datatype</var>] [<var class="keyword varname">number | </var>INTERVAL] '<var class="keyword varname">interval_value</var>') ]
  | [PARTITION <var class="keyword varname">name</var>] 
     END ([<var class="keyword varname">datatype</var>] '<var class="keyword varname">end_value</var>') [INCLUSIVE | EXCLUSIVE]
     [ EVERY ([<var class="keyword varname">datatype</var>] [<var class="keyword varname">number | </var>INTERVAL] '<var class="keyword varname">interval_value</var>') ]
[ WITH ( <var class="keyword varname">partition_storage_parameter</var>=<var class="keyword varname">value</var> [, ... ] ) ]
[column_reference_storage_directive [, …] ]
[ TABLESPACE <var class="keyword varname">tablespace</var> ]</pre>

         <p class="p">where <var class="keyword varname">subpartition_spec</var> or <var class="keyword varname">template_spec</var> is:</p>

         <pre class="pre codeblock">
            <var class="keyword varname">subpartition_element</var> [, ...]</pre>

         <p class="p">and <var class="keyword varname">subpartition_element</var> is:</p>

         <pre class="pre codeblock">   DEFAULT SUBPARTITION <var class="keyword varname">name</var>
  | [SUBPARTITION <var class="keyword varname">name</var>] VALUES (<var class="keyword varname">list_value</var> [,...] )
  | [SUBPARTITION <var class="keyword varname">name</var>] 
     START ([<var class="keyword varname">datatype</var>] '<var class="keyword varname">start_value</var>') [INCLUSIVE | EXCLUSIVE]
     [ END ([<var class="keyword varname">datatype</var>] '<var class="keyword varname">end_value</var>') [INCLUSIVE | EXCLUSIVE] ]
     [ EVERY ([<var class="keyword varname">datatype</var>] [<var class="keyword varname">number</var> | INTERVAL] '<var class="keyword varname">interval_value</var>') ]
  | [SUBPARTITION <var class="keyword varname">name</var>] 
     END ([<var class="keyword varname">datatype</var>] '<var class="keyword varname">end_value</var>') [INCLUSIVE | EXCLUSIVE]
     [ EVERY ([<var class="keyword varname">datatype</var>] [<var class="keyword varname">number</var> | INTERVAL] '<var class="keyword varname">interval_value</var>') ]
[ WITH ( <var class="keyword varname">partition_storage_parameter</var>=<var class="keyword varname">value</var> [, ... ] ) ]
[column_reference_storage_directive [, …] ]
[ TABLESPACE <var class="keyword varname">tablespace</var> ]</pre>

         <p class="p">where <var class="keyword varname">storage_parameter</var> is:</p>

         <pre class="pre codeblock">   APPENDONLY={TRUE}
   BLOCKSIZE={8192-2097152}
   ORIENTATION={COLUMN | ROW | PARQUET}
   COMPRESSTYPE={ZLIB | QUICKLZ | NONE}
   COMPRESSLEVEL={1-9}
   FILLFACTOR={10-100}
   OIDS=[TRUE|FALSE]
   PAGESIZE={1024-1073741823}
   ROWGROUPSIZE={1024-1073741823}</pre>

         <p class="p">where <var class="keyword varname">storage_directive</var> is:</p>

         <pre class="pre codeblock">   COMPRESSTYPE={ZLIB | QUICKLZ | NONE} 
 | COMPRESSLEVEL={0-9} 
 | BLOCKSIZE={8192-2097152}</pre>

         <p class="p">where <var class="keyword varname">column_reference_storage_directive</var> is:</p>

         <pre class="pre codeblock">   COLUMN column_name ENCODING (storage_directive [, ... ] ), ...
 |
   DEFAULT COLUMN ENCODING (storage_directive [, ... ] )</pre>

      </div>

      <div class="section" id="topic1__section3"><h2 class="title sectiontitle">Description</h2>
         
         <p class="p">
            <samp class="ph codeph">CREATE TABLE</samp> creates a new, initially empty table in the current
            database. The table is owned by the user issuing the command. If a schema name is given
            then the table is created in the specified schema. Otherwise it is created in the
            current schema. Temporary tables exist in a special schema, so a schema name may not be
            given when creating a temporary table. The name of the table must be distinct from the
            name of any other table, external table, sequence, or view in the same schema.</p>

         <p class="p">The optional constraint clauses specify conditions that new or updated rows must satisfy
            for an insert or update operation to succeed. A constraint is an SQL object that helps
            define the set of valid values in the table in various ways. Constraints apply to
            tables, not to partitions. You cannot add a constraint to a partition or
            subpartition.</p>

         <p class="p">There are two ways to define constraints: table constraints and column constraints. A
            column constraint is defined as part of a column definition. A table constraint
            definition is not tied to a particular column, and it can encompass more than one
            column. Every column constraint can also be written as a table constraint; a column
            constraint is only a notational convenience for use when the constraint only affects one
            column.</p>

         <p class="p">When creating a table, there is an additional clause to declare the HAWQ distribution
            policy. If a <samp class="ph codeph">DISTRIBUTED BY</samp> or <samp class="ph codeph">DISTRIBUTED RANDOMLY</samp>
            clause is not supplied, then HAWQ assigns a hash distribution policy to the table using
            the first column of the table as the distribution key. Columns of geometric or
            user-defined data types are not eligible as HAWQ distribution key columns. If a table
            does not have a column of an eligible data type, the rows are distributed based on a
            round-robin or random distribution. To ensure an even distribution of data in your HAWQ
            system, you want to choose a distribution key that is unique for each record, or if that
            is not possible, then choose <samp class="ph codeph">DISTRIBUTED RANDOMLY</samp>.</p>

         <p class="p">The <samp class="ph codeph">PARTITION BY</samp> clause allows you to divide the table into multiple
            sub-tables (or parts) that, taken together, make up the parent table and share its
            schema. Though the sub-tables exist as independent tables, HAWQ restricts their use in
            important ways. Internally, partitioning is implemented as a special form of
            inheritance. Each child table partition is created with a distinct
               <samp class="ph codeph">CHECK</samp> constraint which limits the data the table can contain, based
            on some defining criteria. The <samp class="ph codeph">CHECK</samp> constraints are also used by the
            query planner to determine which table partitions to scan in order to satisfy a given
            query predicate. These partition constraints are managed automatically by HAWQ.</p>

      </div>

      <div class="section" id="topic1__section4"><h2 class="title sectiontitle">Parameters</h2>
         
         <dl class="dl parml">
            
               <dt class="dt pt dlterm">GLOBAL | LOCAL</dt>

               <dd class="dd pd">These keywords are present for SQL standard compatibility, but have no effect in
                  HAWQ. </dd>

            
            
               <dt class="dt pt dlterm">TEMPORARY | TEMP</dt>

               <dd class="dd pd">If specified, the table is created as a temporary table. Temporary tables are
                  automatically dropped at the end of a session, or optionally at the end of the
                  current transaction (see <samp class="ph codeph">ON COMMIT</samp>). Existing permanent tables
                  with the same name are not visible to the current session while the temporary
                  table exists, unless they are referenced with schema-qualified names. Any indexes
                  created on a temporary table are automatically temporary as well.</dd>

            
            
               <dt class="dt pt dlterm">
                  <var class="keyword varname">table_name</var>
               </dt>

               <dd class="dd pd">The name (optionally schema-qualified) of the table to be created. </dd>

            
            
               <dt class="dt pt dlterm">
                  <var class="keyword varname">column_name</var>
               </dt>

               <dd class="dd pd">The name of a column to be created in the new table. </dd>

            
            
               <dt class="dt pt dlterm">
                  <var class="keyword varname">data_type</var>
               </dt>

               <dd class="dd pd">The data type of the column. This may include array specifiers.</dd>

            
            
               <dt class="dt pt dlterm">DEFAULT <var class="keyword varname">default_expr</var>
               </dt>

               <dd class="dd pd">The <samp class="ph codeph">DEFAULT</samp> clause assigns a default data value for the column
                  whose column definition it appears within. The value is any variable-free
                  expression (subqueries and cross-references to other columns in the current table
                  are not allowed). The data type of the default expression must match the data type
                  of the column. The default expression will be used in any insert operation that
                  does not specify a value for the column. If there is no default for a column, then
                  the default is null. </dd>

            
            
               <dt class="dt pt dlterm">INHERITS</dt>

               <dd class="dd pd">The optional <samp class="ph codeph">INHERITS</samp> clause specifies a list of tables from
                  which the new table automatically inherits all columns. Use of
                     <samp class="ph codeph">INHERITS</samp> creates a persistent relationship between the new
                  child table and its parent table(s). Schema modifications to the parent(s)
                  normally propagate to children as well, and by default the data of the child table
                  is included in scans of the parent(s). </dd>

               <dd class="dd pd">In HAWQ, the <samp class="ph codeph">INHERITS</samp> clause is not used when creating
                  partitioned tables. Although the concept of inheritance is used in partition
                  hierarchies, the inheritance structure of a partitioned table is created using the
                  PARTITION BY clause. </dd>

               <dd class="dd pd">If the same column name exists in more than one parent table, an error is
                  reported unless the data types of the columns match in each of the parent tables.
                  If there is no conflict, then the duplicate columns are merged to form a single
                  column in the new table. If the column name list of the new table contains a
                  column name that is also inherited, the data type must likewise match the
                  inherited column(s), and the column definitions are merged into one. However,
                  inherited and new column declarations of the same name need not specify identical
                  constraints: all constraints provided from any declaration are merged together and
                  all are applied to the new table. If the new table explicitly specifies a default
                  value for the column, this default overrides any defaults from inherited
                  declarations of the column. Otherwise, any parents that specify default values for
                  the column must all specify the same default, or an error will be reported. </dd>

            
            
               <dt class="dt pt dlterm">LIKE <var class="keyword varname">other_table</var> [{INCLUDING | EXCLUDING} {DEFAULTS |
                  CONSTRAINTS}]</dt>

               <dd class="dd pd">The <samp class="ph codeph">LIKE</samp> clause specifies a table from which the new table
                  automatically copies all column names, data types, not-null constraints, and
                  distribution policy. Storage properties like append-only or partition structure
                  are not copied. Unlike <samp class="ph codeph">INHERITS</samp>, the new table and original table
                  are completely decoupled after creation is complete.</dd>

               <dd class="dd pd">Default expressions for the copied column definitions will only be copied if
                     <samp class="ph codeph">INCLUDING DEFAULTS</samp> is specified. The default behavior is to
                  exclude default expressions, resulting in the copied columns in the new table
                  having null defaults. </dd>

               <dd class="dd pd">Not-null constraints are always copied to the new table. <samp class="ph codeph">CHECK</samp>
                  constraints will only be copied if <samp class="ph codeph">INCLUDING CONSTRAINTS</samp> is
                  specified; other types of constraints will <var class="keyword varname">never</var> be copied.
                  Also, no distinction is made between column constraints and table constraints —
                  when constraints are requested, all check constraints are copied. </dd>

               <dd class="dd pd">Note also that unlike <samp class="ph codeph">INHERITS</samp>, copied columns and constraints
                  are not merged with similarly named columns and constraints. If the same name is
                  specified explicitly or in another <samp class="ph codeph">LIKE</samp> clause an error is
                  signalled. </dd>

            
            
               <dt class="dt pt dlterm">NULL | NOT NULL </dt>

               <dd class="dd pd">Specifies if the column is or is not allowed to contain null values.
                     <samp class="ph codeph">NULL</samp> is the default.</dd>

            
            
               <dt class="dt pt dlterm">CHECK ( <var class="keyword varname">expression</var> )</dt>

               <dd class="dd pd">The <samp class="ph codeph">CHECK</samp> clause specifies an expression producing a Boolean
                  result which new or updated rows must satisfy for an insert or update operation to
                  succeed. Expressions evaluating to <samp class="ph codeph">TRUE</samp> or
                     <samp class="ph codeph">UNKNOWN</samp> succeed. Should any row of an insert or update
                  operation produce a <samp class="ph codeph">FALSE</samp> result an error exception is raised and
                  the insert or update does not alter the database. A check constraint specified as
                  a column constraint should reference that column's value only, while an expression
                  appearing in a table constraint may reference multiple columns.
                     <samp class="ph codeph">CHECK</samp> expressions cannot contain subqueries nor refer to
                  variables other than columns of the current row.</dd>

            
            
               <dt class="dt pt dlterm">WITH ( <var class="keyword varname">storage_option=value</var> )</dt>

               <dd class="dd pd">The <samp class="ph codeph">WITH</samp> clause can be used to set storage options for the table
                  or its indexes. Note that you can also set storage parameters on a particular
                  partition or subpartition by declaring the <samp class="ph codeph">WITH</samp> clause in the
                  partition specification.</dd>

               <dd class="dd pd">
                  <p class="p">Note: You cannot create a table with both column encodings and compression
                     parameters in a WITH clause. </p>

               </dd>

               <dd class="dd pd">The following storage options are available:</dd>

               <dd class="dd pd">
                  <strong class="ph b">APPENDONLY</strong> — Set to <samp class="ph codeph">TRUE</samp> to create the table as an
                  append-only table. If <samp class="ph codeph">FALSE</samp> is specified, an error message
                  displays stating that heap tables are not supported.</dd>

               <dd class="dd pd">
                  <strong class="ph b">BLOCKSIZE</strong> — Set to the size, in bytes for each block in a table. The
                     <samp class="ph codeph">BLOCKSIZE</samp> must be between 8192 and 2097152 bytes, and be a
                  multiple of 8192. The default is 32768.</dd>

               <dd class="dd pd">
                  <strong class="ph b">ORIENTATION</strong> — Set to <samp class="ph codeph">column</samp> for column-oriented storage,
                  or <samp class="ph codeph">row</samp> (the default) for row-oriented storage, or parquet. This
                  option is only valid if <samp class="ph codeph">APPENDONLY=TRUE</samp>. Heap-storage tables can
                  only be row-oriented.</dd>

               <dd class="dd pd">
                  <strong class="ph b">COMPRESSTYPE</strong> — Set to <samp class="ph codeph">ZLIB</samp> (the default) or
                     <samp class="ph codeph">QUICKLZ</samp> to specify the type of compression used. QuickLZ uses
                  less CPU power and compresses data faster at a lower compression ratio than zlib.
                  Conversely, zlib provides more compact compression ratios at lower speeds. This
                  option is only valid if <samp class="ph codeph">APPENDONLY=TRUE</samp>.</dd>

               <dd class="dd pd">
                  <strong class="ph b">COMPRESSLEVEL</strong> — For zlib compression of append-only tables, set to an
                  integer value between 1 (fastest compression) to 9 (highest compression ratio).
                  QuickLZ compression level can only be set to 1. If not declared, the default is 1.
                  This option is valid only if <samp class="ph codeph">APPENDONLY=TRUE</samp>.</dd>

               <dd class="dd pd">
                  <strong class="ph b">OIDS</strong> — Set to <samp class="ph codeph">OIDS=FALSE</samp> (the default) so that rows do not
                  have object identifiers assigned to them. Pivotal strongly recommends that you do
                  not enable OIDS when creating a table. On large tables, such as those in a typical
                  HAWQ system, using OIDs for table rows can cause wrap-around of the 32-bit OID
                  counter. Once the counter wraps around, OIDs can no longer be assumed to be
                  unique, which not only makes them useless to user applications, but can also cause
                  problems in the HAWQ system catalog tables. In addition, excluding OIDs from a
                  table reduces the space required to store the table on disk by 4 bytes per row,
                  slightly improving performance. OIDS are not allowed on partitioned tables or
                  append-only column-oriented tables.</dd>

            
            
               <dt class="dt pt dlterm">ON COMMIT</dt>

               <dd class="dd pd">The behavior of temporary tables at the end of a transaction block can be
                  controlled using <samp class="ph codeph">ON COMMIT</samp>. The three options are: </dd>

               <dd class="dd pd">
                  <strong class="ph b">PRESERVE ROWS</strong> - No special action is taken at the ends of transactions for
                  temporary tables. This is the default behavior. </dd>

               <dd class="dd pd">
                  <strong class="ph b">DELETE ROWS</strong> - All rows in the temporary table will be deleted at the end of
                  each transaction block. Essentially, an automatic <samp class="ph codeph">TRUNCATE</samp> is
                  done at each commit. </dd>

               <dd class="dd pd">
                  <strong class="ph b">DROP</strong> - The temporary table will be dropped at the end of the current
                  transaction block. </dd>

            
            
               <dt class="dt pt dlterm">TABLESPACE <var class="keyword varname">tablespace</var>
               </dt>

               <dd class="dd pd">The name of the tablespace in which the new table is to be created. If not
                  specified, the database's default tablespace dfs_default is used. Creating table
                  on tablespace <samp class="ph codeph">pg_default</samp> is not allowed.</dd>

            
            
               <dt class="dt pt dlterm">DISTRIBUTED BY (<var class="keyword varname">column</var>, [ ... ] )</dt>

               <dt class="dt pt dlterm">DISTRIBUTED RANDOMLY</dt>

               <dd class="dd pd">Used to declare the HAWQ distribution policy for the table. <samp class="ph codeph">DISTIBUTED
                     BY</samp> uses hash distribution with one or more columns declared as the
                  distribution key. For the most even data distribution, the distribution key should
                  be the primary key of the table or a unique column (or set of columns). If that is
                  not possible, then you may choose <samp class="ph codeph">DISTRIBUTED RANDOMLY</samp>, which
                  will send the data round-robin to the segment instances. If not supplied, then
                  hash distribution is chosen using the first eligible column of the table as the
                  distribution key.</dd>

            
            
               <dt class="dt pt dlterm">PARTITION BY</dt>

               <dd class="dd pd">Declares one or more columns by which to partition the table.</dd>

            
            
               <dt class="dt pt dlterm">
                  <var class="keyword varname">partition_type</var>
               </dt>

               <dd class="dd pd">Declares partition type: <samp class="ph codeph">LIST</samp> (list of values) or
                     <samp class="ph codeph">RANGE</samp> (a numeric or date range). </dd>

            
            
               <dt class="dt pt dlterm">
                  <var class="keyword varname">partition_specification</var>
               </dt>

               <dd class="dd pd">Declares the individual partitions to create. Each partition can be defined
                  individually or, for range partitions, you can use the <samp class="ph codeph">EVERY</samp>
                  clause (with a <samp class="ph codeph">START</samp> and optional <samp class="ph codeph">END</samp> clause) to
                  define an increment pattern to use to create the individual partitions.</dd>

               <dd class="dd pd">
                  <strong class="ph b">
                     <samp class="ph codeph">DEFAULT PARTITION <var class="keyword varname">name</var>
                     </samp>
                  </strong> — Declares a default partition. When data does not match to an existing
                  partition, it is inserted into the default partition. Partition designs that do
                  not have a default partition will reject incoming rows that do not match to an
                  existing partition.</dd>

               <dd class="dd pd">
                  <strong class="ph b">
                     <samp class="ph codeph">PARTITION <var class="keyword varname">name</var>
                     </samp>
                  </strong> — Declares a name to use for the partition. Partitions are created using the
                  following naming convention: <samp class="ph codeph">
                     <var class="keyword varname">parentname</var>_<var class="keyword varname">level#</var>_prt_<var class="keyword varname">givenname</var>
                  </samp>.</dd>

               <dd class="dd pd">
                  <strong class="ph b">
                     <samp class="ph codeph">VALUES</samp>
                  </strong> — For list partitions, defines the value(s) that the partition will
                  contain.</dd>

               <dd class="dd pd">
                  <strong class="ph b">
                     <samp class="ph codeph">START</samp>
                  </strong> — For range partitions, defines the starting range value for the partition.
                  By default, start values are <samp class="ph codeph">INCLUSIVE</samp>. For example, if you
                  declared a start date of '<samp class="ph codeph">2008-01-01</samp>', then the partition would
                  contain all dates greater than or equal to '<samp class="ph codeph">2008-01-01</samp>'.
                  Typically the data type of the <samp class="ph codeph">START</samp> expression is the same type
                  as the partition key column. If that is not the case, then you must explicitly
                  cast to the intended data type. </dd>

               <dd class="dd pd">
                  <strong class="ph b">
                     <samp class="ph codeph">END</samp>
                  </strong> — For range partitions, defines the ending range value for the partition. By
                  default, end values are <samp class="ph codeph">EXCLUSIVE</samp>. For example, if you declared
                  an end date of '<samp class="ph codeph">2008-02-01</samp>', then the partition would contain all
                  dates less than but not equal to '<samp class="ph codeph">2008-02-01</samp>'. Typically the data
                  type of the <samp class="ph codeph">END</samp> expression is the same type as the partition key
                  column. If that is not the case, then you must explicitly cast to the intended
                  data type.</dd>

               <dd class="dd pd">
                  <strong class="ph b">
                     <samp class="ph codeph">EVERY</samp>
                  </strong> — For range partitions, defines how to increment the values from
                     <samp class="ph codeph">START</samp> to <samp class="ph codeph">END</samp> to create individual partitions.
                  Typically the data type of the <samp class="ph codeph">EVERY</samp> expression is the same type
                  as the partition key column. If that is not the case, then you must explicitly
                  cast to the intended data type.</dd>

               <dd class="dd pd">
                  <strong class="ph b">
                     <samp class="ph codeph">WITH</samp>
                  </strong> — Sets the table storage options for a partition. For example, you may want
                  older partitions to be append-only tables and newer partitions to be regular heap
                  tables.</dd>

               <dd class="dd pd">
                  <strong class="ph b">
                     <samp class="ph codeph">TABLESPACE</samp>
                  </strong> — The name of the tablespace in which the partition is to be created. </dd>

            
            
               <dt class="dt pt dlterm">SUBPARTITION BY</dt>

               <dd class="dd pd">Declares one or more columns by which to subpartition the first-level partitions
                  of the table. The format of the subpartition specification is similar to that of a
                  partition specification described above. </dd>

            
            
               <dt class="dt pt dlterm">SUBPARTITION TEMPLATE</dt>

               <dd class="dd pd">Instead of declaring each subpartition definition individually for each
                  partition, you can optionally declare a subpartition template to be used to create
                  the subpartitions. This subpartition specification would then apply to all parent
                  partitions.</dd>

            
         </dl>

      </div>

      <div class="section" id="topic1__section5"><h2 class="title sectiontitle">Notes</h2>
         
         <p class="p">Using OIDs in new applications is not recommended: where possible, using a
               <samp class="ph codeph">SERIAL</samp> or other sequence generator as the table's primary key is
            preferred. However, if your application does make use of OIDs to identify specific rows
            of a table, it is recommended to create a unique constraint on the OID column of that
            table, to ensure that OIDs in the table will indeed uniquely identify rows even after
            counter wrap-around. Avoid assuming that OIDs are unique across tables; if you need a
            database-wide unique identifier, use the combination of table OID and row OID for the
            purpose.</p>

         <p class="p">HAWQ has some special conditions for primary key and unique constraints with regards to
            columns that are the <em class="ph i">distribution key</em> in a HAWQ table. For a unique constraint to
            be enforced in HAWQ, the table must be hash-distributed (not <samp class="ph codeph">DISTRIBUTED
               RANDOMLY</samp>), and the constraint columns must be the same as (or a superset of)
            the table's distribution key columns. </p>

         <p class="p">Primary key and foreign key constraints are not supported in HAWQ. For inherited tables,
            table privileges <em class="ph i">are not </em> inherited in the current implementation.</p>

         <p class="p">HAWQ also supports the parquet storage format.</p>

      </div>

      <div class="section"><h2 class="title sectiontitle">Setting Parameters for Parquet Tables:</h2>
         
         <p class="p">You can set three kinds of parameters for a parquet table.</p>

         <ol class="ol" id="topic1__ol_hpq_whs_pp">
            <li class="li">Set the parquet orientation parameter:
               <pre class="pre codeblock">with (appendonly=true, orientation=parquet);</pre>

            </li>

            <li class="li">Set the compression type parameter: Parquet tables can compressed either as
                  <samp class="ph codeph">SNAPPY</samp> or <samp class="ph codeph">GZIP</samp>. When setting to
                  <samp class="ph codeph">SNAPPY</samp>, setting a compression level causes it to fail. You can
               set the <samp class="ph codeph">GZIP</samp> compression level between 1 - 9. If you specify a
               compression level but not a compression type when creating parquet table, the
               compression type defaults to <samp class="ph codeph">GZIP</samp>. <div class="note note"><span class="notetitle">Note:</span> The compress types
                     <samp class="ph codeph">ZLIB</samp> and <samp class="ph codeph">QUICKLZ</samp> are valid for AO/CO tables,
                  while <samp class="ph codeph">SNAPPY</samp> and <samp class="ph codeph">GZIP</samp> are valid for parquet
                  tables.</div>

            </li>

            <li class="li">Set the data storage parameter: By default, the two parameters,
                  <samp class="ph codeph">PAGESIZE</samp> and <samp class="ph codeph">ROWGROUPSIZE</samp> are set to 1MB/8MB for
               common and partitioned tables. <div class="note note"><span class="notetitle">Note:</span> The page size should be less than the rowgroup
                  size. This is because rowgroup includes the metadata information of a single page
                  even for a single column table. The parameters <samp class="ph codeph">PAGESIZE</samp> and
                     <samp class="ph codeph">ROWGROUPSIZE</samp> are valid for parquet tables, while
                     <samp class="ph codeph">BLOCKSIZE</samp> is valid for AO/CO tables</div>

            </li>

         </ol>

      </div>

      <div class="section"><h2 class="title sectiontitle">About Parquet Storage</h2>
         
         <p class="p">DDL and DML: Most DDL and DML operations are valid for a parquet table. The usage for
            DDL and DML operations is similar to AO tables. Valid operations on parquet tables
            include:</p>

         <ul class="ul" id="topic1__ul_yyq_whs_pp">
            <li class="li">parquet table creation (with/without partition, with/without compress type)</li>

            <li class="li">insert and select</li>

         </ul>

         <p class="p">
            <strong class="ph b">Compress type and level</strong>: You can only set the compression type at the table
            level. HAWQ does not support setting column level. The specified compression type is
            propagated to the columns. All the columns must have same compress type/level.</p>

         <p class="p">
            <strong class="ph b">Data type</strong>: HAWQ supports all data types except arrays and User defined types.</p>

         <p class="p">
            <strong class="ph b">Alter table</strong>: HAWQ does not support adding and dropping a new column to an
            existing parquet table. You can use <samp class="ph codeph">ALTER TABLE</samp> for a partition
            operation.</p>

         <p class="p">
            <strong class="ph b">FillFactor/OIDS/Checksum</strong>: HAWQ does not support these operations when creating
            parquet tables. The default value for checksum for a parquet table is false. You cannot
            set this value or specify fillfactor and oids.</p>

         <p class="p">
            <strong class="ph b">Memory occupation</strong>: When inserting or loading data to a parquet table, the whole
            rowgroup is stored in physical memory. It is stored in physical memory until the size
            exceeds the threshold or the end of the <samp class="ph codeph">INSERT</samp> operation. Once either
            occurs, the entire rowgroup is flushed to the disk.Also, at the beginning of the
               <samp class="ph codeph">INSERT</samp> operation, each column is pre-allocated a page buffer. The
            column pre-allocated page buffer size should be <samp class="ph codeph">min(pageSizeLimit,
               rowgroupSizeLimit/estimatedColumnWidth/estimatedRecordWidth)</samp> for the first
            rowgroup. For the following rowgroup, it should be <samp class="ph codeph">min(pageSizeLimit,
               actualColumnChunkSize in last rowgroup * 1.05)</samp>, of which 1.05 is the
            estimated scaling factor. When reading data from a parquet table, the requested columns
            of the row group are loaded into memory. Memory is allocated 8 MB by default. Ensure
            that memory occupation not exceed physical memory when setting
               <samp class="ph codeph">ROWGROUPSIZE</samp> or <samp class="ph codeph">PAGESIZE</samp>, otherwise you may
            encounter OOM. </p>

      </div>

      <div class="section"><h2 class="title sectiontitle">Parquet Examples</h2>
         
         <p class="p">
            <strong class="ph b">Parquet Example 1</strong>
         </p>

         <pre class="pre codeblock">CREATE TABLE parquet_wt_subpartgzip1(id SERIAL, int,char(5),numeric, boolean DEFAULT false, char DEFAULT 'd', text, timestamp, character varying(705),bigint, date,a11 varchar(600),text, decimal, real, bigint, int4, bytea, timestamp with time zone, timetz, path, box, macaddr, interval, character varying(800), lseg, point, double precision, circle, int4, numeric(8), polygon, date, real, money, cidr, inet, time, text, bit, bit varying(5), smallint, int); 
WITH (appendonly=true, orientation=parquet); 
distributed randomly;
Partition by range(a1) 
Subpartition by list(a2) 
subpartition template (
default subpartition df_sp, subpartition sp1 values('M'), 
subpartition sp2 values('F')
WITH (appendonly=true, orientation=parquet,compresstype=gzip,compresslevel=1)) 
(start(1) end(5000) every(1000) );</pre>

         <p class="p">
            <strong class="ph b">Parquet Example 2</strong>
         </p>

         <pre class="pre codeblock">CREATE TABLE parquet_wt_subpartgzip1_exch(
id SERIAL,int, char(5), numeric, boolean DEFAULT false, char DEFAULT 'd', text, timestamp, character varying(705), bigint, date,a11 varchar(600), text, decimal, real, bigint, int4 , bytea, timestamp with time zone, timetz, path, box, macaddr, interval, character varying(800), lseg, point, double precision, circle, int4, numeric(8), polygon, date, real, money, cidr, inet, time, text, bit, bit varying(5), smallint, int) 
WITH (appendonly=true, orientation=parquet, compresstype=gzip) 
distributed randomly;</pre>

         <p class="p">
            <strong class="ph b">Parquet Example 3</strong>
         </p>

         <pre class="pre codeblock">Alter table parquet_wt_subpartgzip1 alter partition FOR (
RANK(1)) 
exchange partition sp1 with table parquet_wt_subpartgzip1_exch;\d+ parquet_wt_subpartgzip1_1_prt_1_2_prt_sp1</pre>

      </div>

      <div class="section"><h2 class="title sectiontitle">AO Examples</h2>
         
         <p class="p">
            <strong class="ph b">AO Example 1</strong>: Create a table named rank in the schema named baby and distribute
            the data using the columns rank, gender, and year:</p>

         <pre class="pre codeblock">CREATE TABLE baby.rank (id int, rank int, year smallint,gender char(1), count int ) DISTRIBUTED BY (rank, gender,year);</pre>

         <p class="p">
            <strong class="ph b">AO Example 2</strong>: Create table films and table distributors (the first column will be
            used as the HAWQ distribution key by default):</p>

         <pre class="pre codeblock">CREATE TABLE films (
code char(5),
title varchar(40) NOT NULL,
did integer NOT NULL,
date_prod date,
kind varchar(10),
len interval hour to minute
);
CREATE TABLE distributors (
did integer,
name varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);</pre>

         <p class="p">
            <strong class="ph b">AO Example 3</strong>: Create a gzip-compressed, append-only table:</p>

         <pre class="pre codeblock">CREATE TABLE sales (txn_id int, qty int, date date)
WITH (appendonly=true, compresslevel=5)
DISTRIBUTED BY (txn_id);</pre>

         <p class="p">
            <strong class="ph b">AO Example 4</strong>: Create a three level partitioned table using subpartition templates
            and default partitions at each level:</p>

         <pre class="pre codeblock">CREATE TABLE sales (id int, year int, month int, day int,
region text)
DISTRIBUTED BY (id)
PARTITION BY RANGE (year)
SUBPARTITION BY RANGE (month)
SUBPARTITION TEMPLATE (
START (1) END (13) EVERY (1),
DEFAULT SUBPARTITION other_months )
SUBPARTITION BY LIST (region)
SUBPARTITION TEMPLATE (
SUBPARTITION usa VALUES ('usa'),
SUBPARTITION europe VALUES ('europe'),
SUBPARTITION asia VALUES ('asia'),
DEFAULT SUBPARTITION other_regions)
( START (2002) END (2010) EVERY (1),
DEFAULT PARTITION outlying_years);</pre>

      </div>

      <div class="section" id="topic1__section7"><h2 class="title sectiontitle">Compatibility</h2>
         
         <p class="p">
            <samp class="ph codeph">CREATE TABLE</samp> command conforms to the SQL standard, with the following
            exceptions:</p>

         <ul class="ul">
            <li class="li" id="topic1__cd150267">
               <strong class="ph b">Temporary Tables</strong> — In the SQL standard, temporary tables are defined just once
               and automatically exist (starting with empty contents) in every session that needs
               them. HAWQ instead requires each session to issue its own <samp class="ph codeph">CREATE TEMPORARY
                  TABLE</samp> command for each temporary table to be used. This allows different
               sessions to use the same temporary table name for different purposes, whereas the
               standard's approach constrains all instances of a given temporary table name to have
               the same table structure. <p class="p">The standard's distinction between global and local
                  temporary tables is not in HAWQ. HAWQ will accept the <samp class="ph codeph">GLOBAL</samp> and
                     <samp class="ph codeph">LOCAL</samp> keywords in a temporary table declaration, but they have
                  no effect. </p>

               <p class="p">If the <samp class="ph codeph">ON COMMIT</samp> clause is omitted, the SQL standard specifies
                  that the default behavior as <samp class="ph codeph">ON COMMIT DELETE ROWS</samp>. However, the
                  default behavior in HAWQ is <samp class="ph codeph">ON COMMIT PRESERVE ROWS</samp>. The
                     <samp class="ph codeph">ON COMMIT DROP</samp> option does not exist in the SQL standard. </p>

            </li>

            <li class="li" id="topic1__cd150376">
               <strong class="ph b">Column Check Constraints</strong> — The SQL standard says that <samp class="ph codeph">CHECK</samp>
               column constraints may only refer to the column they apply to; only
                  <samp class="ph codeph">CHECK</samp> table constraints may refer to multiple columns. HAWQ does
               not enforce this restriction; it treats column and table check constraints alike. </li>

            <li class="li" id="topic1__cd150386">
               <strong class="ph b">NULL Constraint</strong> — The <samp class="ph codeph">NULL</samp> constraint is a HAWQ extension to
               the SQL standard that is included for compatibility with some other database systems
               (and for symmetry with the <samp class="ph codeph">NOT NULL</samp> constraint). Since it is the
               default for any column, its presence is not required.</li>

            <li class="li" id="topic1__cd150401">
               <strong class="ph b">Inheritance</strong> — Multiple inheritance via the <samp class="ph codeph">INHERITS</samp> clause is
               a HAWQ language extension. SQL:1999 and later define single inheritance using a
               different syntax and different semantics. SQL:1999-style inheritance is not yet
               supported by HAWQ. </li>

            <li class="li" id="topic1__cd153512">
               <strong class="ph b">Partitioning</strong> — Table partitioning via the <samp class="ph codeph">PARTITION BY</samp> clause
               is a HAWQ language extension. </li>

            <li class="li" id="topic1__cd150414">
               <strong class="ph b">Zero-column tables</strong> — HAWQ allows a table of no columns to be created (for
               example, <samp class="ph codeph">CREATE TABLE foo();</samp>). This is an extension from the SQL
               standard, which does not allow zero-column tables. Zero-column tables are not in
               themselves very useful, but disallowing them creates odd special cases for
                  <samp class="ph codeph">ALTER TABLE DROP COLUMN</samp>, so Pivotal decided to ignore this spec
               restriction. </li>

            <li class="li" id="topic1__cd150435">
               <strong class="ph b">WITH clause</strong> — The <samp class="ph codeph">WITH</samp> clause is a Pivotal extension; neither
               storage parameters nor OIDs are in the standard. </li>

            <li class="li" id="topic1__cd150445">
               <strong class="ph b">Tablespaces</strong> — The HAWQ concept of tablespaces is not part of the SQL standard.
               The clauses <samp class="ph codeph">TABLESPACE</samp> and <samp class="ph codeph">USING INDEX TABLESPACE</samp>
               are extensions. </li>

            <li class="li" id="topic1__cd150459">
               <strong class="ph b">Data Distribution</strong> — The HAWQ concept of a parallel or distributed database is
               not part of the SQL standard. The <samp class="ph codeph">DISTRIBUTED</samp> clauses are
               extensions.</li>

         </ul>

      </div>

      <div class="section" id="topic1__section8"><h2 class="title sectiontitle">See Also</h2>
         
         <p class="p">
            <samp class="ph codeph">
               <a class="xref" href="ALTER-TABLE.html">ALTER TABLE</a>
            </samp>, <samp class="ph codeph">
               <a class="xref" href="DROP-TABLE.html">DROP TABLE</a>
            </samp>, <samp class="ph codeph">
               <a class="xref" href="CREATE-EXTERNAL-TABLE.html">CREATE EXTERNAL TABLE</a>
            </samp>, <samp class="ph codeph">
               <a class="xref" href="CREATE-TABLE-AS.html">CREATE TABLE AS</a>
            </samp>
         </p>

      </div>

   </div>

<div class="related-links"/>
<div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../hawq-topics/SQLCommandReference.html" title="SQL Command Reference"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">SQL Command Reference</span></a></span>  </div><div>
<div class="container">
  <footer class="site-footer-links">
    <div class="copyright">
      <a href="http://docs.pivotal.io" target="_blank">Pivotal Documentation</a>
      © 2014 <a href="http://www.pivotal.io/" target="_blank">Pivotal Software</a>, Inc. All Rights Reserved.
  </div>
  <div class="support">
    Need help? <a href="http://support.pivotal.io" target="_blank">Visit Support</a>
   </div>
  </footer>
</div><!--end of container-->
</div>
</body>
</html>